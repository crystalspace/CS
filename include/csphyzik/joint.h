/*
    Dynamics/Kinematics modeling and simulation library.
    Copyright (C) 1999 by Michael Alexander Ewert

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public
    License along with this library; if not, write to the Free
    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

*/

#ifndef CT_JOINT_H
#define CT_JOINT_H

#include "csphyzik/phyztype.h"
#include "csphyzik/math3d.h"
#include "csphyzik/ctvspat.h"

class ctArticulatedBody;
class ctForce;

#define JOINT_STATESIZE 2   // joint velocity and acceleration

// a joint that links together and constrains the motion of two articulated bodies 
// inboard means articulated body that is closer to the root of the whole
// outboard is the opposite
class ctJoint
{
public:

	// static values
	static double joint_friction;

	ctJoint(){ 	q = qv = qa = 0; }
	ctJoint( ctArticulatedBody *in, ctVector3 &in_offset, ctArticulatedBody *out, ctVector3 &out_offset );
	
	// add v and w (angular v) of the outboard link, contributed from joints state
	virtual void calc_vw( ctVector3 &v, ctVector3 &w ) = 0;
	// calc corioulous force generated by this joint.  Result goes in c
	// r is vector from center of inboard handle to center of outboard handle.
	// w_f is the angular velocity of inboard handle.
	virtual void calc_coriolus( const ctVector3 &r, const ctVector3 &w_f, ctSpatialVector &c ) = 0;
	virtual ctSpatialVector get_spatial_joint_axis() = 0;
	virtual real get_actuator_magnitude( real external_f, real inertail_comp );

	virtual int get_state_size(){ return JOINT_STATESIZE; }// = 0;
	virtual int set_state( real *sa );
	virtual int get_state( const real *sa );
	virtual int set_delta_state( real *state_array ); 

	// update the body_to_world reference frame of the outboard body given a 
	// transformation matrix from inboard to outboard frames of reference
	void update_link_RF( ctMatrix3 &R_fg );
	
	// return vector from inboard center to outboard center in outboard coords
	ctVector3 get_r();

	ctArticulatedBody *inboard;
	// offset from center of inboard link to this joint ( at end of inboard link )
	// in inboard frame.
	ctVector3 inboard_offset;
	ctArticulatedBody *outboard;
	// points from joint axis to origin of outboard entity in outboard frame
	ctVector3 outboard_offset;  // d in Mirtch thesis
	
	ctVector3 joint_axis;  // in outboard frame o' reference
	real q, qv, qa;  // joint position, velocity and acceleration in radians

protected:
//!me go through and hide all data that should be hidden


};

// joint that slides in and out
class ctPrismaticJoint : public ctJoint
{
public:
	virtual void calc_vw( ctVector3 &v, ctVector3& /*w*/ ){ 
		v = v + joint_axis *qv;
	}

	virtual void calc_coriolus( const ctVector3 &r, const ctVector3 &w_f, ctSpatialVector &c );

	virtual ctSpatialVector get_spatial_joint_axis();

};

// a hinge
class ctRevoluteJoint : public ctJoint
{
public:

	ctRevoluteJoint( ctArticulatedBody *in, ctVector3 &in_offset, ctArticulatedBody *out, ctVector3 &out_offset, ctVector3 &paxis );

	virtual void calc_vw( ctVector3 &v, ctVector3 &w ){ 
		w = w + joint_axis*qv;
		v = v + ( joint_axis % outboard_offset )*qv;
	}

	virtual void calc_coriolus( const ctVector3 &r, const ctVector3 &w_f, ctSpatialVector &c );

	virtual ctSpatialVector get_spatial_joint_axis();
};


#endif
