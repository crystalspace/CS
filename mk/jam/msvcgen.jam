#==============================================================================
# Rules for creating MSVC project files.
# Copyright (C) 2003 by Matze Braun <matzebraun@users.sourceforge.net>
# Copyright (C) 2004 by Eric Sunshine <sunshine@sunshineco.com>
#
#    This library is free software; you can redistribute it and/or modify it
#    under the terms of the GNU Library General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or (at your
#    option) any later version.
#
#    This library is distributed in the hope that it will be useful, but
#    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
#    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
#    License for more details.
#
#    You should have received a copy of the GNU Library General Public License
#    along with this library; if not, write to the Free Software Foundation,
#    Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#==============================================================================
#
# During a project file synthesis run, the property name 'projgen' in the
# container 'build' will be given a value describing which type of project
# files are being generated. For MSVC project files, the value of the 'projgen'
# property will be "msvc". When project file synthesis supports multiple tool
# versions, the 'projgen_version' property will have a value indicating the
# version of the tool for which project files are being created. For instance,
# when generating MSVC7 project files, 'projgen' will be set to "msvc" and
# 'projgen_version' will have the value "7".
#
# Jamfiles throughout the project, if they need to alter their behavior (for
# one reason or another), can invoke the Property rule to determine whether
# project files are being synthesized.  For example, to learn if project file
# synthesis is active:
#
# if [ Property build : projgen ] { ... do something ... }
#
# To take action if only a particular type of project file is being generated
# (i.e. "msvc"):
#
# if [ Property build : projgen ] = msvc { ... do something ... }
#
#==============================================================================

MSVCGEN_BUILD_ROOT = [ ConcatDirs $(BUILDTOP) out ] ;

rule msvcgen_build_dir
{ return [ ConcatDirs $(MSVCGEN_BUILD_ROOT) mk ] ; }
rule msvcgen_target_dir
{ return [ ConcatDirs [ msvcgen_build_dir ] visualc$(<) ] ; }
rule msvcgen_fragment_dir
{ return [ ConcatDirs [ msvcgen_build_dir ] fragment$(<) ] ; }
rule msvcgen_template_dir
{ return [ ConcatDirs $(TOP) mk msvcgen template$(<) ] ; }

if ! $(DO_MSVCGEN)
{
MSVCGEN_SILENT ?= no ;
JAM ?= jam ;
if $(MSVCGEN_SILENT) = yes { JAM += -d0 ; }

## MsvcGenConfig configfile
## MsvcGenConfig variable : value
##   Specify additional configuration information to augment the msvcgen
##   environment.  If one argument is provided, then it is a file containing
##   Jam statements providing additional configuration for the msvcgen process.
##   In the common case, the file will contain a series of simple variable
##   assignment statements.  If two arguments are provided, then the named
##   'variable' is set to 'value' for the msvcgen run.  Invocations of the
##   two-argument form of MsvcGenConfig are cumulative, so variable/value
##   tuples can be provided incrementally.  It is legal to use both forms of
##   MsvcGenConfig; they are not mutually exclusive.
##
##   The most common reason to invoke this rule is to provide MSVC-specific
##   fallback values for the library checks typically performed by an Autoconf
##   configure script, which the Jamfiles reference via the ExternalLibs rule.
##   Such fallbacks consist of variables named TAG.CFLAGS, TAG.LFLAGS, and
##   TAG.LIBS, where TAG represents the library's identifier exported by the
##   configure script.  For instance, to provide MSVC-specific fallback values
##   for the FreeType2 library, which the configure script might identify as
##   FT2, you can define variables named FT2.CFLAGS, FT2.LFLAGS, and FT2.LIBS.
##   The msvcgen process will consult these variables when it encounters
##   invocations of the ExternalLibs rule, and apply the overrides to the
##   generated project files.  If yours is a multi-platform project which
##   conditionally defines Application, Plugin, and Library targets based upon
##   the platform, then you should also define whatever additional variables or
##   properties are needed to ensure that your project's Jamfiles invoke the
##   Application, Plugin, and Library rules for modules suitable for Windows,
##   and that they do not invoke those rules for modules specific to other
##   platforms.
rule MsvcGenConfig
{
  if $(>)
  {
    MSVCGEN_CONFIG_TUPLES += "-s$(<)=$(>)" ;
  }
  else
  {
    MSVCGEN_CONFIG = $(<) ;
  }
}

## MsvcGenWorkspace name [ : accepts [ : rejects ]]
##   Specify the name of a workspace which the 'msvcgen' target should create.
##   The generated workspace file name will be prefixed by "wks".  By default,
##   a workspace contains all projects resulting from invocations of the
##   Application, Plugin, Library, and CompileGroups. It is possible to
##   restrict the projects placed into the workspace by providing the optional
##   'accepts' and/or 'rejects'. These are lists of Perl regular expressions
##   matched against the project names. (Project names are composed of "app",
##   "plg", "lib", and "grp" prepended to the target name given to the
##   Application, Plugin, Library, and CompileGroups rules, respectively.)
##   Reject patterns take precedence over accept patterns.  This rule must be
##   invoked before any invocations of Application, Plugin, Library, or
##   CompileGroups.  You may invoke this rule multiple times to produce
##   multiple workspaces, but you must invoke it at least once in order for the
##   'msvcgen' target to produce any output.
rule MsvcGenWorkspace
{
  # Implemented below.
}

## MsvcGenTarget version
##   Create pseudo-targets for building and removing project files for the
##   specified version of MSVC.  Also populates the list MSVCGEN_TARGETS with
##   names of the targets.  Clients which need to perform some pre-processing
##   prior to the actual msvcgen run may set the targets in this list to depend
##   upon client-supplied targets.
rule MsvcGenTarget
{
  Always msvc$(<)gen ;
  NotFile msvc$(<)gen ;
  MSVC_VERSION on msvc$(<)gen = $(<) ;
  MsvcGen msvc$(<)gen ;
  Depends msvcgen : msvc$(<)gen ;
  Help msvc$(<)gen : "Create MSVC$(<) project files" ;
  MSVCGEN_TARGETS += msvc$(<)gen ;
  CleanDir msvc$(<)clean :
    [ msvcgen_target_dir $(<) ] [ msvcgen_fragment_dir $(<) ] ;
  Depends msvcclean : msvc$(<)clean ;
  Help msvc$(<)clean : "Remove built MSVC$(<) project files" ;
}

actions MsvcGen
{
  $(JAM) -sDO_MSVCGEN=yes -sMSVCGEN_CONFIG=$(MSVCGEN_CONFIG) \
    -sMSVC_VERSION=$(MSVC_VERSION) -sTARGET.OS=WIN32 $(MSVCGEN_CONFIG_TUPLES) \
    msvcgen
}

MsvcGenTarget 6 ;
MsvcGenTarget 7 ;

Always msvcgen ;
NotFile msvcgen ;
Help msvcgen : "Create MSVC project files (all versions)" ;

CleanDir msvcclean : [ msvcgen_build_dir ] ;
Help msvcclean : "Remove built MSVC project files (all versions)" ;
Depends clean : msvcclean ;

}
else
{

if $(MSVCGEN_CONFIG)
{
  include $(MSVCGEN_CONFIG) ;
}

PERL ?= perl ;
MSVCGEN = $(PERL) [ ConcatDirs $(TOP) mk msvcgen msvcgen.pl ] ;
MERGERES = $(SHELL) [ ConcatDirs $(TOP) libs csutil win32 mergeres.sh ] ;

MSVC_VERSION ?= 7 ;
MSVCGEN_LOCATE_TARGET   ?= [ msvcgen_target_dir   $(MSVC_VERSION) ] ;
MSVCGEN_LOCATE_FRAGMENT ?= [ msvcgen_fragment_dir $(MSVC_VERSION) ] ;
MSVCGEN_TEMPLATEDIR     ?= [ msvcgen_template_dir $(MSVC_VERSION) ] ;

if $(MSVC_VERSION) = 6
{
  MSVCGEN_EXTRA_OPTS = ;
  SSUFPRJ = dsp ;
  SSUFWSP = dsw ;
  SUFPRJ = .dsp ;
  SUFWSP = .dsw ;
}
else if $(MSVC_VERSION) = 7
{
  MSVCGEN_EXTRA_OPTS = --xml-protect ;
  SSUFPRJ = vcproj ;
  SUFPRJ = .vcproj ;
  SSUFWSP = sln ;
  SUFWSP = .sln ;
}
else
{
  EXIT "No msvcgen support for MSVC version $(MSVC_VERSION) yet!" ;
}
  
MSVC.DEPEND ?= ;
MSVC.LIBRARY ?= ;
MSVC.LFLAGS ?= ;
MSVC.CFLAGS ?= ;
MSVC.DEPEND.appgui ?= ;
MSVC.LIBRARY.appgui ?= ;
MSVC.LFLAGS.appgui ?= ;
MSVC.CFLAGS.appgui ?= ;
MSVC.DEPEND.appcon ?= ;
MSVC.LIBRARY.appcon ?= ;
MSVC.LFLAGS.appcon ?= ;
MSVC.CFLAGS.appcon ?= ;
MSVC.DEPEND.plugin ?= ;
MSVC.LIBRARY.plugin ?= ;
MSVC.LFLAGS.plugin ?= ;
MSVC.CFLAGS.plugin ?= ;
MSVC.DEPEND.library ?= ;
MSVC.LIBRARY.library ?= ;
MSVC.LFLAGS.library ?= ;
MSVC.CFLAGS.library ?= ;

SetProperty build : projgen : msvc ;
SetProperty build : projgen_version : $(MSVC_VERSION) ;

#----------------------------------------------------------------------------
# Override some rules

## MsvcGenConfig configfile
## MsvcGenConfig variables : values
##   (See documentation above.)
rule MsvcGenConfig
{
}

## MsvcGenWorkspace name [ : accepts [ : rejects ]]
##   (See documentation above.)
rule MsvcGenWorkspace
{
  local name = $(1) ;
  MSVC.WORKSPACES += $(name) ;
  MSVC.ACCEPTS.$(name) = $(2) ;
  MSVC.REJECTS.$(name) = $(3) ;
}

## MsvcProject target : type : target-with-ext : sources
## MsvcProject target : type : target-with-ext : accepts : rejects
##   Create a project file for 'target', which is the project's raw name.
##   If 'type' is not "group", then 'sources' is a list of files comprising
##   the target. If 'type' is "group", then 'accepts' and 'rejects' are the
##   Perl regular-expression lists indicating which dependencies of the group
##   should be accepted and rejected, respectively.
rule MsvcProject
{
  local rawname = $(1) ;
  local type = $(2) ;
  local decorated = $(3) ;
  local sources = $(4) ;
  local accepts = $(4) ;
  local rejects = $(5) ;

  local msvcname ;
  switch $(type)
  {
    case appgui :
      msvcname = app$(rawname) ;
    case appcon :
      msvcname = app$(rawname) ;
    case plugin :
      msvcname = plg$(rawname) ;
    case library :
      msvcname = lib$(rawname) ;
    case group :
      msvcname = grp$(rawname) ;
    case * :
      exit "Unknown msvc projecttype: $(type) specified!" ;
  }
  $(rawname)_MSVCNAME = $(msvcname) ;
      
  local fragroot = [ ConcatDirs $(MSVCGEN_LOCATE_FRAGMENT) $(msvcname).frag ] ;
  NotFile $(fragroot) ;

  local fragments = [ FAppendSuffix $(msvcname) : .frag.cff ]
		    [ FAppendSuffix $(msvcname) : .frag.dpf ]
		    [ FAppendSuffix $(msvcname) : .frag.pjf ] ;
  MakeLocate $(fragments) : $(MSVCGEN_LOCATE_FRAGMENT) ;

  local target = [ FAppendSuffix $(msvcname) : $(SUFPRJ) ] ;
  MakeLocate $(target) : $(MSVCGEN_LOCATE_TARGET) ;
  target += $(fragments) ;
  $(rawname)_TARGET = $(target) ;

  # Only include source and headers files for now.  In the future, we also
  # want to include .cfg files and any other textual resources which which the
  # user might care to read/view in the MSVC IDE.
  local i, files ;
  for i in $(sources)
  {
    if [ IsElem $(i:S) : .h .hpp .H .c .cc .cpp .C .m .mm .M ]
    {
      files += $(i:G=$(LOCATE_SOURCE)) ;
    }
  }
  # Search at the correct place for the files
  SEARCH on $(files) = $(SEARCH_SOURCE) ;

  # Add resource file.
  if [ IsElem $(type) : plugin appgui appcon ]
  {
    local resource = $(msvcname:S=.rc) ;
    files += $(resource) ;
    Depends $(target) : $(resource) ;
    MakeLocate $(resource) : $(MSVCGEN_LOCATE_TARGET) ;
    SEARCH on $(resource) = $(MSVCGEN_LOCATE_FRAGMENT) ;
    NAME on $(resource) = $(rawname) ;
    $(rawname)_RCNAME = $(resource) ;
  
    local versionrc = $(resource:S=.vrctmp) ;
    MakeLocate $(versionrc) : $(MSVCGEN_LOCATE_FRAGMENT) ;
    MakeVersionRc $(versionrc) : $(rawname) ;
    Always $(versionrc) ;
    Win32Resource $(rawname) : $(versionrc) ;
    RmTemps $(resource) : $(versionrc) ;
    
    if $(type) = "plugin" 
    {
      local metarc = $(resource:S=.mrctmp) ;
    
      MakeLocate $(metarc) : $(MSVCGEN_LOCATE_FRAGMENT) ;
      SEARCH on $(metarc) = $(SEARCH_SOURCE) ;
    
      Depends $(metarc) : $($(rawname)_METAFILE) ;
      GenerateWin32MetadataRc $(metarc) : $($(rawname)_METAFILE) ;
      Always $(metarc) ;
      Win32Resource $(rawname) : $(metarc) ;
      RmTemps $(resource) : $(metarc) ;
    }

    if [ IsElem $(type) : appgui appcon ]
    {
      local icon = [ ApplicationIcon win32 : $(rawname) ] ;
      if ! $(icon)
      {
	local apptype = gui ;
	if $(type) = "appcon" { apptype = console ; }
	icon = [ ApplicationIconDefault win32 : $(apptype) ] ;
      }
      if $(icon)
      {
	local iconrc = $(resource:S=.irctmp) ;
      
	MakeLocate $(metarc) : $(MSVCGEN_LOCATE_FRAGMENT) ;
    
	GenerateIconRc $(iconrc) : $(icon) ;
    
	Win32Resource $(rawname) : $(iconrc) ;
	RmTemps $(resource) : $(iconrc) ;
      }
    }
  
    Always $(resource) ;
  }
  
  RAWNAME on $(target) = $(rawname) ;
  PROJECTNAME on $(target) = $(msvcname) ;
  TARGET on $(target) = $(decorated) ;
  TYPE on $(target) = $(type) ;
  FRAGMENT_ROOT on $(target) = $(fragroot) ;
  DEPEND on $(target) += $(MSVC.DEPEND) $(MSVC.DEPEND.$(type)) ;
  LIBRARIES on $(target) += $(MSVC.LIBRARY) $(MSVC.LIBRARY.$(type)) ;
  LFLAGS on $(target) += $(MSVC.LFLAGS) $(MSVC.LFLAGS.$(type)) ;
  CFLAGS on $(target) += $(MSVC.CFLAGS) $(MSVC.CFLAGS.$(type)) ;

  if $(type) = "group"
  {
    ACCEPTS on $(target) = $(accepts) ;
    REJECTS on $(target) = $(rejects) ;
  }
  else
  {
    ACCEPTS on $(target) = ;
    REJECTS on $(target) = ;
  }

  local filelist = [ ResponseFile $(msvcname:G=msvcgen$(rawname):S=.filelist) :
    $(files) : $(MSVCGEN_LOCATE_FRAGMENT) ] ;
  Always $(filelist) ;
  Depends $(target) : $(files) $(filelist) ;
  Depends msvcgen : $(target) ;
  MsvcProjectGen $(target) : $(filelist) ;
  Always $(target) ;
  RmTemps $(target) : $(filelist) ;

  if ! $(MSVC.WORKSPACES)
  {
    exit "You must specify at least one workspace via MsvcGenWorkspace" ;
  }

  local w ;
  for w in $(MSVC.WORKSPACES)
  {
    MSVCWorkspace $(w) : $(fragments) : $(fragroot) ;
  }

  Clean msvcclean : $(target) ;
}

# MSVCWorkspace name : fragments : fragmentroot
rule MSVCWorkspace
{
  local name = $(1) ;
  local fragments = $(2) ;
  local fragroot = $(3) ;
  local target = wks$(name) ;
  target = $(target:G=msvcworkspace:S=$(SUFWSP)) ;

  RAWNAME on $(target) = $(name) ;

  local filelist = [ ResponseFile $(target:G=msvcgen$(name):S=.filelist) :
    $(fragroot) : $(MSVCGEN_LOCATE_FRAGMENT) ] ;
  Always $(filelist) ;

  Depends $(target) : $(fragments[1]) $(filelist) ;
  Depends msvcgen : $(target) ;
  MakeLocate $(target) : $(MSVCGEN_LOCATE_TARGET) ;
  MsvcWorkspaceGen $(target) : $(filelist) ;
  RmTemps $(target) : $(filelist) ;
  RmTemps msvcgen : $(fragments) ;
}

#----------------------------------------------------------------------------

# Ensure that the pseudo-groups exist with which the overridden Application,
# Plugin, and Library rules will register their targets. We have to do this
# here rather than at the top-level (outside of any rule invocation) because we
# need to give the client time to invoke MsvcGenWorkspace first to set up the
# workspaces into which these groups will be inserted. If we tried registering
# theses pseudo-groups at the top-level, registration would occur before the
# client has had a chance to invoke MsvcGenWorkspace, thus these pseudo-groups
# would not inhabit any workspaces.
rule RegisterWellKnownCompileGroups
{
  if $(MSVCGEN.WELL_KNOWN_GROUPS_REGISTERED) != yes
  {
    MSVCGEN.WELL_KNOWN_GROUPS_REGISTERED = yes ;
    RegisterCompileGroups all apps plugins libs ;
  }
}

rule Application
{
  RegisterWellKnownCompileGroups ;

  local projtype ;
  if [ IsElem console : $(3) ]
  {
    projtype = appcon ;
  }
  else
  {
    projtype = appgui ;
  }
  MsvcProject $(<) : $(projtype) : $(<:S=.exe) : $(>) ;
  CompileGroups $(<) : all apps ;
}

rule Plugin
{
  RegisterWellKnownCompileGroups ;

  local metafile ;
  metafile = [ FAppendSuffix $(<) : $(SUFMETA) ] ;
  SEARCH on $(metafile) = $(SEARCH_SOURCE) ;
  $(<)_METAFILE = $(metafile) ;
  MsvcProject $(<) : plugin : $(<:S=.dll) : $(>) ;
  CompileGroups $(<) : all plugins ;
}

rule Library
{
  RegisterWellKnownCompileGroups ;
  $(<)_TYPE = library ;
  MsvcProject $(<) : library : $(<:S=.lib) : $(>) ;
  CompileGroups $(<) : all libs ;
}

rule RegisterCompileGroups
{
  local i ;
  for i in $(<)
  {
    local w ;
    for w in $(MSVC.WORKSPACES)
    {
      MsvcProject
        $(i)_$(w) : group : : $(MSVC.ACCEPTS.$(w)) : $(MSVC.REJECTS.$(w)) ;
    }
  }
}

rule CompileGroups
{
  local i ;
  for i in $(>)_$(MSVC.WORKSPACES)
  {
    DEPEND on $($(i)_TARGET) += $($(<)_MSVCNAME) ;
  }
}

rule LinkWith
{
  DEPEND on $($(<)_TARGET) += lib$(>) ;
  MsvcLFlags $(<) : $($($(>).EXTERNALLIBS).LFLAGS) ;
  MsvcExternalLibrary $(<) : $($($(>).EXTERNALLIBS).LIBS) ;
}

rule MsvcExternalLibrary
{
  LIBRARIES on $($(<)_TARGET) += $(>) ;
}

rule MsvcCFlags
{
  if $(>) { CFLAGS on $($(<)_TARGET) += $(>) ; }
}

rule MsvcLFlags
{
  if $(>) { LFLAGS on $($(<)_TARGET) += $(>) ; }
}

rule ExternalLibs
{
  local i ;
  for i in $(>)
  {
    MsvcCFlags $(<) : $($(i).CFLAGS) ;
    MsvcLFlags $(<) : $($(i).LFLAGS) ;
    MsvcExternalLibrary $(<) : $($(i).LIBS) ;
    
    if $($(<)_TYPE) = library
    {
      $(<).EXTERNALLIBS += $(i) ;
    }
  }
}

# Normal invocations of these two rules are made using Unix-style flags;
# possibly determined by an Autoconf configuration script.  Such flags are
# unsuitable for MSVC, so we ignore them.
rule CFlags { }
rule LFlags { }

rule Win32Resource
{
  Depends $(<) : $($(<)_RCNAME) ;
  Depends $($(<)_RCNAME) : $(>) ;
  MergeRcs $($(<)_RCNAME) : $(>) ;
}

#----------------------------------------------------------------------------

# Implementation note: The --strip-root directives are order-sensitive when the
# build directory is the same as the source directory, in which case TOP is "."
# and MSVCGEN_BUILD_ROOT is "./out".  If TOP incorrectly appeared first, then
# it would invalidate the following --strip-root option since TOP is a prefix
# of MSVCGEN_BUILD_ROOT.
actions MsvcProjectGen
{
  $(MSVCGEN) \
  --quiet \
  --project \
  $(MSVCGEN_EXTRA_OPTS) \
  --project-extension=$(SSUFPRJ) \
  --name=$(RAWNAME) \
  --template=$(TYPE) \
  --template-dir=$(MSVCGEN_TEMPLATEDIR) \
  --project-name=$(PROJECTNAME) \
  --output=$(<[1]) \
  --target=$(TARGET) \
  --fragment=$(FRAGMENT_ROOT) \
  --depend=$(DEPEND) \
  --library=$(LIBRARIES) \
  --lflags='$(LFLAGS)' \
  --cflags='$(CFLAGS)' \
  --strip-root='$(MSVCGEN_BUILD_ROOT)/' \
  --strip-root='$(TOP)/' \
  --accept='$(ACCEPTS)' \
  --reject='$(REJECTS)' \
  --response-file=$(>)
}

actions together MsvcWorkspaceGen
{
  $(MSVCGEN) \
  --quiet \
  --workspace \
  $(MSVCGEN_EXTRA_OPTS) \
  --workspace-extension=$(SSUFWSP) \
  --output=$(<) \
  --template-dir=$(MSVCGEN_TEMPLATEDIR) \
  --accept='$(MSVC.ACCEPTS.$(RAWNAME))' \
  --reject='$(MSVC.REJECTS.$(RAWNAME))' \
  --response-file=$(>)
}

actions together MergeRcs
{
  $(MERGERES) '$(<)' '$(TOP)' '../..' '$(>)'
}

#----------------------------------------------------------------------------

NotFile msvcgen ;
Always msvcgen ;
}
