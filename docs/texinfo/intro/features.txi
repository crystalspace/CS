@c -*-texinfo-*-
@node Feature List, Where to Get, UsingForProject, CS Introduction
@section Feature List
@cindex Features

The first feature to mention is that Crystal Space is an open source project.
It falls under the GNU copyleft license (LGPL). @xref{License}.

Crystal Space is divided into several libraries. The items in the feature
list are sorted by the library they belong to. Note that this is not a
description how these libraries work together. Some libraries are even
not mentioned here.

Currently Crystal Space has the following features:

@table @emph
@item System Driver
A system library that will perform system-dependent operations for your
program. This way your program is easily portably to any supported system.
It includes a good plug-in system that offers you an interface to
dynamically loaded drivers (@file{.so} or @file{.dll}), like the 3D rasterizer.

@item Geometry Library
A 3D math library, including 2D and 3D vectors, matrices and polygons.
This libary can be used without the rest of Crystal Space.

@item 2D Canvas / 3D Renderer
These libraries allow you to draw directly on the screen, and to use
hardware accelerated 3D drawing. They are independent from the engine and
perform only basic operations. You can actually use them if you want to
write your own engine. The libraries include:

@itemize @bullet
@item
Direct3D for Windows port.

@item
OpenGL support for GNU/Linux, BeOS, Macintosh, OS/2, and Windows.

@item
Glide support for GNU/Linux and BeOS.

@item
Drawing arbitrary sloped convex polygons.

@item
Perspective correct texture mapping. You can chose between accuracy
and speed (by selecting the interpolation step).

@item
Support for 8-bit (palette), 15/16-bit and 32-bit truecolor displays
(no support for 24-bit yet).

@item
Mipmapping to minimize memory strain on the texture cache and to have
nicer textures in the distance.

@item
The width and height of textures must be a power of two but the
texture need not be a square.

@item
Procedural textures. Currently the included procedural textures are plasma,
sky, water, and fire. You can define your own procedural textures.

@item
It is possible to map the texture on a polygon in various ways such as via
rotation, scaling, mirroring, etc.

@item
Transparent and semi-transparent textures allowing for see-through
water surfaces and windows.

@item
Colored volumetric fog.

@item
Halos around lights.
@end itemize

@item 3D Engine
The engine features the following:

@itemize @bullet
@item
True six-degrees-of-freedom (@sc{6dof}).

@item
Integrated landscape engine.

@item
Moving objects and scripts controlling the movement.

@item
Static colored lighting with real shadows. Lighting and shadows are
precomputed before the world is displayed. Radiosity is also supported.

@item
Pseudo-dynamic colored lights which cannot move but have very accurate
shadows and can change intensity/color randomly.

@item
Dynamic colored lighting with support for shadows (detail objects are
ignored for shadows currently).

@item
Support for frame and skeletal based 3D triangle mesh sprites with
level-of-detail (@sc{lod}) reduction via progressive meshes!

@item
Support for 2D sprites and particle systems.

@item
Mesh object plugin system that is used for 3D sprites, 2D sprites and
particle systems. The game developer can also write his own mesh objects
and plug them into the engine transparently.

@item
Portals are used for efficient and easy visibility sorting. In
addition you can optionally enable an @sc{octree} and/or @sc{bsp} for some
sectors to allow for even more powerful world definitions.

@item
Additional C-buffer (coverage buffer) which can be enabled for even
better visibility culling.

@item
Using portals you can also create transparent and semi-transparent
mirrors.

@item
Alpha transparency in combination with mirrors allows simulation of
shining walls.

@item
You can also include gouraud shaded triangles in the world.

@item
Dynamic gouraud shaded sky spheres. Also support for skybox.

@item
Curved bezier surfaces with dynamic tesselation depending on viewer
distance.

@item
Support for multiple cameras and the ability to make 1st person or
3rd person cameras.

@item
@sc{zip} archive format to pack the map file, the textures and all other
needed data files for one level inside one file. Crystal Space will also
use the same @sc{zip} file to automatically add lightmap data. This will
greatly speed up the start-up of Crystal Space.

@item
Powerful text-based map file format allows you to easily redefine the world.

@item
Libraries of commonly used objects and textures are supported.
@end itemize

@item Utility Library
Much of the utility functionality in this library can be used independently
of Crystal Space.  This library includes the following functionality:

@itemize @bullet
@item
Reading configuration (@sc{ini}) files for program options.

@item
Reading and writing @sc{zip} files as data files.

@item
Simple parser that you can use if @sc{ini} files are not enough. It is used
by the engine to read map files.

@item
Defining an interface for shared libraries (@file{.so} or @sc{.dll}).  This is
used by the plug-in system.

@item
Dynamically-sized arrays (@code{csVector}).
@end itemize

@item @sc{vfs}
Virtual file system.  @xref{VFS}.

@item Sound Driver / Sound Renderer
General sound system.  Currently drivers exist for GNU/Linux, Macintosh, and
Windows.

@item Network Driver
General networking support.  Currently supports socket-based networking via
@sc{TCP/IP}.

@item Scripting
Crystal Space supports scripting through the @sc{Python} plugin. That way
a game using Crystal Space can call @sc{Python} methods and @sc{Python}
scripts can call Crystal Space methods.
@end table
