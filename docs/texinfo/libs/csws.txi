@c -*-texinfo-*-
@node CSWS, , csGeom, Facilities
@section Crystal Space Windowing System (@sc{csws})
@cindex CSWS
@cindex Libraries,CSWS
@cindex Windowing System

@noindent
@emph{Written by Andrew Zabolotny, @email{bit@@eltech.ru}.}

@noindent
@strong{Warning}: @emph{This facility is heavily deprecated, unmaintained, and
no longer developed.  Instead, use @sc{aws}.  @xref{AWS}.}

The main goal of Crystal Space Windowing System (@sc{csws}) is to provide a
clean, effective and cross-platform base for creating Crystal Space-related
utilities.  The goal for writing this manual is not to give a extensive overview
of the windowing system, but rather to give the basic concepts so that you have
something to start with.

@menu
* CSWS Concepts:: Concepts
* CSWS Components:: Components
* CSWS Events:: Events
* CSWS Clipping:: Clipping
* CSWS Tutorial:: Quick Tutorial
@end menu

@node CSWS Concepts, CSWS Components, CSWS, CSWS
@subsection Concepts

There is nothing new in @sc{csws} regarding the window system.  All base
conceptions for building such an system were invented long ago, at least when
first X-Windows system was built, or even earlier.

The system is event-based, events are generated by hardware (mouse, keyboard)
or software (components can send messages to each other).  Event-system is
system-dependent as well as graphics subsystem.  They were developed first as
part of Crystal Space itself, then some modifications were made to better fit
@sc{csws} requirements.  @sc{csws} itself is completely system-independent,
i.e. you can easily develop programs that will compile and work with no
problems under any system supported by Crystal Space.

Since Crystal Space always uses buffered visuals, the screen repainting is
always done on the invisible page.  This means flickering on redraw is almost
impossible in @sc{csws}, while it is common on many @sc{gui}s with
poorly-written programs.  If visual has more than one @dfn{back-buffer}, the
image is automatically re-synchronized on all back-buffers, but this slows down
the refresh.  Thus if your program is mostly using the windowing system it is
advised that you disable double-buffering before using the windowing system.

Another Crystal Space-specific feature is the division of event processing into
@dfn{frames}.  Since Crystal Space is a animation engine it operates in terms
of frames, thus when the frame begins, all pending events in event queue are
processed, then all invalid components are redrawn, and at last the image is
blitted onto the screen.  Note that @sc{csws} shares the global event queue
used by all plug-ins (and strictly speaking @sc{csws} behaves like a plug-in
from system driver's point of view).  This means other plug-ins can ``steal''
events from the windowing system (if they improperly designed).

@subheading Basic Concepts

This section provides an overview of the basic concepts of coordinate system
and color palette.  These discussions provide a solid foundation for
subsequent discussions.

@subsubheading Coordinate System

The coordinate system is based on most-used (yet undesirable) system where
top-left corner is (0,0) and bottom-right corner is (@var{width},
@var{height}).  It would be better to use the more desirable coordinate system
which is used, but most programmers are already familiar with the less
desirable one.

Most @sc{csws} functions works with rectangles (@samp{csRect} class).  The
@samp{csRect} class has four data fields: @samp{xmin}, @samp{xmax},
@samp{ymin}, and @samp{ymax}, which are self-explanatory.  Here is a example
of the rectangle (@var{xmin} = 0, @var{ymin} = 0, @var{xmax} = 3, @var{ymax} =
2):

@example
     0  1  2  3  4 ...
     |  |  |  |  |  |
 0 --##########--+--+--
     #//|//|//#  |  |
 1 --#--+--+--#--+--+--
     #//|//|//#  |  |
 2 --##########--+--+--
     |  |  |  |  |  |
 3 --+--+--+--+--+--+--
     |  |  |  |  |  |
...--+--+--+--+--+--+--
@end example

Vertical line @samp{X = 3} and horizontal line @samp{Y = 2} do @emph{not}
belong to the rectangle.  The hashed pixels belong to the rectangle.  So, if
you have two windows: (0, 0) - (3, 2) and (3, 0) - (6, 2) they do @emph{not}
overlap.

@subsubheading Palette

@sc{csws} has been designed to operate transparently and independent of screen
geometry or number of colors.  To allow normal operation in different pixel
format conditions colors are kept in a dynamically-built table which is
referenced through indexes in that table.  To allow different palettes for
windowing system each component does not use colors directly when drawing,
instead each component has a pointer to a table which contains color values.
So, for example, a component can have a palette which's first element is used
as background color, second is used to display text in window and so on.  By
changing only the palette table we can change at once how all these components
are looking.

There are a number of pre-defined colors with names of the form
@samp{cs_Color_@var{XXX}}, for example @samp{cs_Color_Black},
@samp{cs_Color_White} etc.  There are some colors with varying intensities
which are named @samp{cs_Color_@var{YYY}_@var{Z}}; where @var{YYY} is something
like @samp{Blue}, @samp{Red}, and so on; and the @var{Z} suffix stands for the
intensity---@samp{D} for dark, @samp{M} for medium, @samp{L} for light.

There are a small number of pre-defined colors.  What if you want to use a
color that is not predefined as a screen-depth-independent constant?  The
answer is, you can use @code{csApp::FindColor()} to find a integer
representation of the color (which is very hardware dependent) given the
<@var{r},@var{g},@var{b}> components of the color (where @var{r},
@var{g}, and @var{b} are in the range 0-255).  Then you use the returned color
identifier in the same places where a @samp{cs_Color_@var{XXX}} value is
expected.

Note that the @code{FindColor()} method never fails: it always returns the
nearest available color.  But keep in mind that if you have a palette full of
just black and white colors and you ask for bright red, you will most likely
get some sort of white (or gray) color, rather than red.  Palette management is
outside of the scope of this document; see the @cite{Texture Manager}
documentation instead.

To avoid hard-coding colors into the windowing system components do not draw
with @samp{cs_Color_@var{XXX}} constants.  Instead, they just indicate the
index into the palette representing the color they wish to use.  All standard
component palettes are contained in @file{cswspal.cpp} and @file{cswspal.h}.

There is no need to add your palettes to @file{cswspal.cpp}; that file is just
a convenience for standard windowing system components.  Your components should
define their own palettes (if desired) and set the palette at startup (in the
constructor) using the @code{SetPalette()} method.  Then you draw using palette
indices, just like standard @sc{csws} components.  It is strongly advised to
not use numerical indices for this, but instead define a set of macros of the
form @samp{@var{XX}PAL_@var{YYYY}_BACKGROUND},
@samp{@var{XX}PAL_@var{ZZZZ}_ACTIVETEXT} and so on; where @var{XX} is the short
name of your application (@samp{CS} for @samp{C}rystal @samp{S}pace, @samp{MZ}
for MazeD, the Maze Editor, and so on); @var{YYYY} and @var{ZZZZ} are the names
of the respective components, and the suffix gives the meaning of that palette
entry.

For illustration here are the palette indices for the standard @sc{csws}
scroll bar palette:

@example
#define CSPAL_SCROLLBAR_BACKGROUND      0
#define CSPAL_SCROLLBAR_SELBACKGROUND   1
#define CSPAL_SCROLLBAR_DARK3D          2
#define CSPAL_SCROLLBAR_LIGHT3D         3
@end example

If you want to change a specific palette entry for a @emph{specific} component,
you can use the @code{SetColor()} method.  You should provide a index into the
target component's palette and a color (one of @samp{cs_Color_@var{XXX}}
constants defined above).  For example, to set the background color for some
scrollbar to bright red, you can use the call:

@example
csScrollBar* sb; // @r{Assume that this points at a scroll bar.}
sb->SetColor(CSPAL_SCROLLBAR_BACKGROUND, cs_Color_Red_L);
@end example

@node CSWS Components, CSWS Events, CSWS Concepts, CSWS
@subsection Components

The base class for windowing system is @samp{csComponent}.  @samp{csComponent}
is a very complex class with a lot of built-in functionality.  This allows for
easier creation of new components for specific needs.  Most @samp{csComponent}
methods are virtual, allowing you to override them if needed.  There are some
basic methods, which are described below.  Other methods are described as
needed later in this document.

@subsubheading Drawing: @code{csComponent::Draw()}

Each component should know how to paint itself.  When windowing system thinks
a part of a component image or entire component image is invalid (for example,
when a window is moved from the top of other components), it adds that
rectangle to the @dfn{dirty} rectangle of the component.  The dirty rectangle
is initially empty, then all invalid rectangles are added to it.  At the end
of each frame windowing system sends a broadcast event with @samp{cscmdRedraw}
command code.  When component catches this event, it calls @code{Redraw()}
method which in turn calls @code{csComponent::Draw()}.  After
@code{csComponent::Draw()} returns control, the dirty rectangle is emptied
again.  Before calling the @code{Draw()} method, @code{Redraw()} sets the
component's clipping rectangle to the dirty rectangle, so usually you don't
have to take care to not draw outside the dirty rectangle; clipping will take
care of it for you (to minimize the number of draw operations).

All draw operations are clipped first against dirty rectangle and then against
all component children and neighbors.  So drawing inside a component does not
change even a pixel in other components, even if component is partially covered
by other components.

There are a number of drawing operations that you can use.  Other operations
can be synthesized from existing.  All coordinates used for drawing are
component-origin related, so (0,0) corresponds to component top-left corner.

Here is a list of the primitive drawing methods:

@itemize @bullet
@item
@code{Line(@var{x1}, @var{y1}, @var{x2}, @var{y2}, @var{colorindex})}

Draw a line from (@var{x1}, @var{y1}) to (@var{x2}, @var{y2}).  Example:
@code{Line(0, 0, 3, 3)} produces the following output:

@example
     0  1  2  3  4 ...
     |  |  |  |  |  |
 0 --#--+--+--+--+--+--
     |//|  |  |  |  |
 1 --+--#--+--+--+--+--
     |  |//|  |  |  |
 2 --+--+--#--+--+--+--
     |  |  |//|  |  |
 3 --+--+--+--#--+--+--
     |  |  |  |//|  |
...--+--+--+--+--+--+--
@end example

@item
@code{Box(@var{xmin}, @var{ymin}, @var{xmax}, @var{ymax}, @var{colorindex})}

Draw a filled box that is closed between lines @code{(X >= @var{xmin})},
@code{(X < @var{xmax})}, @code{(Y >= @var{ymin})} and @code{(Y < @var{ymax})}.
Example: @code{Box(0, 0, 3, 2)} will produce the following output:

@example
     0  1  2  3  4 ...
     |  |  |  |  |  |
 0 --#--#--#--+--+--+--
     |//|//|//|  |  |
 1 --#--#--#--+--+--+--
     |//|//|//|  |  |
 2 --+--+--+--+--+--+--
     |  |  |  |  |  |
...--+--+--+--+--+--+--
@end example

@item
@code{Text(@var{x}, @var{y}, @var{foregroundindex}, @var{backgroundindex}, @var{textstring})}

Display a text string starting from (@var{x}, @var{y}) with color
@var{foregroundindex} and background @var{backgroundindex}.  If
@var{backgroundindex} is -1, the text is drawn transparently.  To determine
text width and height you can use the @code{TextWidth(@var{textstring})} and
@code{TextHeight()} functions.  There are a number of built-in @sc{csws}
fonts, they can be used by calling @code{SetFont(cs_Font_@var{XXXX})}.  Note
that both @code{TextWidth()} and @code{TextHeight()} depends on current font.

@item
@code{Sprite2D(@var{sprite2d}, @var{x}, @var{y}, @var{w}, @var{h})}

Draw a 2D sprite or bitmap.  @var{sprite2d} is a object of @samp{csPixmap}
class.  Sprite can have transparent colors, this way you can define
@dfn{holes} in textures.  (You can omit @var{w} and @var{h} to use normal
sprite size.)

@item
@code{Rect3D(@var{xmin}, @var{ymin}, @var{xmax}, @var{ymax}, @var{darkindex}, @var{lightindex})}

Draw a 3D-looking rectangle.  This method just draws four lines to form a
non-filled rectangle.  Example: @code{Rect3D(0, 0, 4, 4)}.

@example
     0  1  2  3  4 ...
     |  |  |  |  |  |
 0 --#--#--#--#--+--+--
     |LL|LL|LL|DD|  |
 1 --#--+--+--#--+--+--
     |LL|  |  |DD|  |
 2 --#--+--+--#--+--+--
     |LL|  |  |DD|  |
 3 --#--#--#--#--+--+--
     |LL|DD|DD|DD|  |
 4 --+--+--+--+--+--+--
     |  |  |  |  |  |
@end example

@item
@code{ObliqueRect3D(@var{xmin}, @var{ymin}, @var{xmax}, @var{ymax}, @var{cornersize}, @var{darkindex}, @var{lightindex})}

Draw a rectangle with oblique corners of given size.  For example, calling
@code{ObliqueRect3D(0, 0, 10, 7, 3)} draws an oblique rectangle such as the
following:

@example
     0  1  2  3  4  5  6  7  8  9 ...
     |  |  |  |  |  |  |  |  |  |  |
 0 --+--+--#--#--#--#--#--#--#--#--+--
     |  |  |LL|LL|LL|LL|LL|LL|LL|DD|
 1 --+--#--+--+--+--+--+--+--+--#--+--
     |  |LL|  |  |  |  |  |  |  |DD|
 2 --#--+--+--+--+--+--+--+--+--#--+--
     |LL|  |  |  |  |  |  |  |  |DD|
 3 --#--+--+--+--+--+--+--+--+--#--+--
     |LL|  |  |  |  |  |  |  |  |DD|
 4 --#--+--+--+--+--+--+--+--+--#--+--
     |LL|  |  |  |  |  |  |  |  |DD|
 5 --#--+--+--+--+--+--+--+--#--+--+--
     |LL|  |  |  |  |  |  |  |DD|  |
 6 --#--#--#--#--#--#--#--#--+--+--+--
     |LL|DD|DD|DD|DD|DD|DD|DD|  |  |
...--+--+--+--+--+--+--+--+--+--+--+--
@end example

@item
@code{SetClipRect(@var{xmin}, @var{ymin}, @var{xmax}, @var{ymax})}

Define a local clipping rectangle for subsequent drawing operations. For
example, when drawing a button you may want to set clipping rectangle after
drawing button borders so that button text accidentally won't draw over its
borders even if it does not fit. To disable clipping you can define an empty
rectangle (@code{SetClipRect(0, 0, 0, 0)});

@item
@code{Pixel(@var{x}, @var{y})}

Plot the pixel at @code{<@var{x},@var{y}} with the current color.

@item
@code{Clear(@var{color})}

Clears the entire area of the component.  Equivalent to:

@example
@code{Box(0, 0, @var{bound}.Width(), @var{bound}.Height(), color)}.
@end example

@item
@code{ClearZbuffer(@var{xmin}, @var{ymin}, @var{xmax}, @var{ymax})}

Clear the Z-buffer in the given rectangle.  Useful if you draw 3D Z-buffered
polygons inside your window.

@item
@code{Polygon3D(@var{poly}, @var{mode})}

Draw a 3D polygon (clipped to the window).  The @samp{@var{poly}} structure is
of the @samp{G3DPolygonDPFX} type, which is defined in @file{igraph3d.h}.  This
structure should be filled, as usual with the vertices, texturing information,
and so on.  The @samp{@var{mode}} parameters is the same as the one in
@code{iGraphics3D::DrawPolygonFX()}; that is, it defines the mode in which to
draw the polygon (@emph{gouraud}, @emph{mix mode}, @emph{alpha}, and so on).
@end itemize

@subsubheading Event Handling: @code{csComponent::HandleEvent(iEvent&)}

This is the main component entry point for handling windowing system events.
Each time user presses a key, moves mouse etc windowing system generates a
event and sends it to appropriate component.  The normal event flow is top-down,
i.e.  the root window receives events first, then passes them if appropriate to
its children which passes it to their respective children and so on.  However,
there are some basic constraints on event flow that you should know about:

@itemize @bullet
@item
@code{HandleEvent()} should return a boolean value that states whenever this
object used the event or not.  If the event has been used, no other component
will receive it anymore, otherwise windowing system looks for other appropriate
candidates for this event.  The only exception from this rule are broadcast
events that are sent to all children independently of the fact that component
@emph{eaten} event or not.

@item
Mouse events are received only by the topmost component mouse pointer is over
and its parents.  If other behavior is desired, a component should capture
the mouse by calling @code{app->CaptureMouse(this)}---in this case mouse
events are sent by application object directly to the object that captured the
mouse, bypassing normal event flow.  To revert to normal mode of operation
component should call @code{app->CaptureMouse(0)}.

@item
Keyboard events are sent only to components from @dfn{focus chain}
(@pxref{CSWS Focus Chain}).  If a different behavior is desired, component
should capture keyboard events by calling @code{app->CaptureKeyboard(this)}.
To disable capturing keyboard events component should call
@code{app->CaptureKeyboard(0)}.

@item
Command events are not sent to child windows.  A reply to command event is
normally expected from the component it has been sent to, not from any of its
children.  Moreover, re-sending command events to children can be dangerous
since the initial event can be sent by one of child components, and the
application can get caught in an endless loop.  Re-sending command events to
parents is a normal practice, for example all menus re-send command events to
their parents since commands are usually sent to menus by their children (menu
items or even sub-menus).  In general, most components that generates events
sends them to their parents: buttons, scrollbars, input fields, list boxes, and
so on.  The @samp{csDialog} component handles unknown command events in a
special way: it re-sends the event to the parent, thus if you inserted a dialog
into a window, and some buttons into the dialog, you don't have to subclass the
dialog in order to receive button notifications in @code{csDialog}'s
@code{HandleEvent()}.  Instead you can subclass the window.  In most cases you
will want to subclass the window anyway).

@item
Broadcast events are the only type of events that are guaranteed to reach every
object in a subtree of components.  That is, if you send a broadcast event to
some component, every child of that component is @emph{guaranteed} to receive
that event as well.  For this reason broadcast commands are used to notify all
components, regardless of hierarchy, about some event.  For example the
@samp{cscmdRedraw} broadcast tells every component to repaint itself.
(However, you should not handle this event yourself since that is done by
@code{csComponent::HandleEvent()}, automatically.)

@end itemize

Aside from the exceptions above, in all other cases the events are processed
from the root of the component's hierarchy (e.g.  the @samp{csApp} object) down
along every branch and can reach every component in the tree (unless the event
is @emph{eaten} somewhere).  Other than broadcast events, any ``true'' return
code from a component's @code{HandleEvent()} method means that the event has
been @emph{eaten} and should not be sent to any other components.  The
tree-like event propagation is performed by @code{csComponent::HandleEvent()},
in addition to a lot of other important things, thus you always should call the
parent class' @code{HandleEvent()} method to avoid confusing the windowing
system.

There is another method called @code{csComponent::PreHandleEvent()} which is
much like @code{HandleEvent()} except that it is called for each event pulled
from event queue before @code{HandleEvent()}, and without rules above, i.e.
any component can preprocess any hardware-generated event before it is sent
along normal event handling chain.  This can be used for popup menus, hot keys
and so on.  If @code{PreHandleEvent()} returns true, the event is considered
@emph{eaten} and is discarded.  Be careful with this feature to avoid
interfering with normal component functions.

And last method related to event processing is
@code{csComponent::PostHandleEvent()}.  It is called when no component handled
the event and it is called for all components in @emph{parent-to-child} order.
It can be used to process events that nobody wants, for example it is used to
process hotkeys on buttons (if active component is for example, a input line,
and user presses @kbd{A} key it should be entered into input text, while if
active component is a non text-hungry component (for example, a list box) the
@kbd{A} key can be used by some button to activate itself).

@subsubheading @samp{csComponent} Members

The @samp{csComponent} class has a number of data fields.  The most important
are summarized here.

@table @code
@item csRect bound
This defines the physical bounds of the component.  All drawing operations
happens inside and are clipped to this bound.  Component does not have control
over any other pixel outside this bound.  The bounds are defined relative to
parent's origin.  For example, if we have a component with bounds (@var{xmin}
= 20, @var{ymin} = 10, @var{xmax} = 100, @var{ymax} = 50) and it has a child
at (10, 10, 30, 40) then its real (physical) pixel coordinates are (20+10,
10+10, 20+30, 10+40).  A child is always clipped to the bounds of all its
parents (however, there is a exception from this rule).

@item int state
Contains the state flags of the component.  There are two types of state flags
(although @sc{csws} does not make a difference between them)--@dfn{dynamic}
flags and @dfn{option} flags.  Option flags usually define some static aspect
of component---for example, whenever component is selectable (i.e. if it can
become the focused element), or it is partially transparent (see
irregularly-shaped components) etc.  Dynamic flags often changes during
component's life, for example component visibility flag, ``component focused''
flag and so on.  The component state flags starts with the @samp{CSS_} prefix.

You should never manually change state flags.  Instead, there are two methods
for this: @code{SetState(@var{mask}, @var{state})} and
@code{GetState(@var{mask})}.  For example, if component is not selectable and
you want to make it selectable, call @code{component.SetState(CSS_SELECTABLE,
true)}.  The @code{SetState()} method is virtual and is often overridden to
execute some specific functions when component state changes.  For example,
default @code{SetState()} handler shows or hides the component if
@samp{CSS_VISIBLE} flag state changes.

@item csRect dirty
Contains the @dfn{dirty} rectangle.  If it is non-empty, the dirty area of
component is redrawn just before the end-of-frame.

@item int DragStyle
Contains a combination of bits (defined by constants with names such as
@code{CS_DRAG_@var{XXX}}) that defines which sides of component can be dragged
with mouse when you call first the @code{csComponent::Drag()} method.  By
default it is equal to @samp{CS_DRAG_ALL}.  Note that if component won't call
@code{csComponent::Drag()} you won't be able to resize the component even if
@samp{DragStyle} is equal to @samp{CS_DRAG_ALL}.

@item csApp *app
This is the ``main'' application object; the root of entire window tree.  It
is a descendant of @samp{csApp} class which is a superclass of
@samp{csComponent}.  @samp{csApp} has some application-global methods such as
@samp{CaptureMouse}, @samp{CaptureKeyboard}, it contains the global mouse
pointer object and many other.

@item csComponent *parent
Contains the @dfn{parent} component.  Components are chained into a tree, each
component knows its neighbors (through @samp{next} and @samp{prev} fields),
each parent knows its focused child, and can traverse its list of children by
starting from focused, then going to @emph{focused-to-next} and so on.

@item csComponent *prev
@itemx csComponent *next
Contains the next and previous neighbors in parent's child list.  They are
never @code{0}, chains are always closed.  If a component is the only child
of another, its next and prev fields points to himself.

@anchor{CSWS Focus Chain}
@item csComponent *focused
This is the focused child component.  For example, keyboard events are sent
only to components in @dfn{focused} chain, i.e. to @samp{app},
@samp{app->focused}, @samp{app->focused->focused} and so on.  If component
does not have any child components, focused is @code{0}.  This is the only
possible case when ``focused'' can be @code{0}.

@item csComponent *top
This is the top component in Z-order.  Mouse events are processed in Z-order
unlike keyboard events.  The focused event is not necessarily the top
component, although usually this is true.  If component has
@samp{CSS_TOPSELECT} flag set, when user activates (focuses) a component, it
is made the topmost, however if it has this flag reset, its Z-order does not
change.

@item int id
This is component's identifier.  This is a user-definable value, but it is
expected to be unique within all children of a parent component.  You can
search for child components with given identification by calling
@code{parent->GetChild(int @var{find_id})}.
@end table

@node CSWS Events, CSWS Clipping, CSWS Components, CSWS
@subsection Events

There are several event types (other event types can be defined as needed, but
existing set covers all current @sc{csws} needs).  There is the base event
class called @samp{csEvent}.  It has several public data fields, the mostly
used is Type which contains the event type.  There are following currently
defined event types:

@table @code
@item csevNothing
The so-called ``empty'' event; mostly used internally by @sc{csws}.

@item csevKeyDown
Key has been pressed event.

@item csevKeyUp
Key has been released event.  On @samp{csevKeyUp} and @samp{csevKeyDown}
events the following data fields in event object are also valid:

@table @code
@item Key.Code
Contains code of key that has been pressed or released.  It can be a literal
value (@samp{A}, @samp{z}, @samp{$}) or one of predefined
@samp{CSKEY_@var{XXX}} values (@samp{CSKEY_UP}, @samp{CSKEY_ESC},
@samp{CSKEY_SPACE}, @samp{CSKEY_ENTER}, etc.).

@item Key.Modifiers
Contains the state of shift keys at time when this event has been generated.
Note that it not necessarily is the same as current key state.  To decode its
value you should use the pre-defined @samp{CSMASK_@var{XXX}} constants.  For
example to check if the @kbd{@key{Alt}} modifier was pressed, and only this
modifier you might use this code:

@example
if ((Event.Key.Modifiers & CSMASK_ALLSHIFTS) ==
  CSMASK_ALT)
@{
  @dots{} ALT + Event.Key.Code pressed @dots{}
@}
@end example

@noindent
Or, alternately, to check if @kbd{@key{Alt}} was pressed, but not necessarily
the only modifier key pressed, you could do it this way:

@example
if (Event.Key.Modifiers & CSMASK_ALT)
@{
  @dots{} (at least ALT) + Event.Key.Code pressed @dots{}
@}
@end example

@noindent
Also there is a bit in @samp{Modifiers} called @samp{CSMASK_FIRST} that is set
only when key is pressed for first time.  With this you can separate actual
key presses from autorepeated keyboard events.
@end table

@item csevMouseMove
Mouse moved event.

@item csevMouseDown
A mouse button was pressed event.

@item csevMouseUp
A mouse button was released event.  On all mouse events the following data
fields in event object are also valid:

@table @code
@item Mouse.x
@itemx Mouse.y
The screen position where mouse event happened.  Mouse position is always
converted to component coordinate system, i.e. @samp{Mouse.x == 0} and
@samp{Mouse.y == 0} means that mouse is at component top-left system.

@item Button
Mouse button number, counting from 1. Not valid for ``mouse moved'' event.

@item Key.Modifiers
Contains the state of shift keys at time when this event has been generated.
See above for comments on shift keys.
@end table

@item csevCommand
A command event.  Command events are generated by windowing system components,
not by hardware.  For example, when a button is pressed, it sends a command
event with some command code to its parent component.  There is only one data
field for this type of events called @samp{Info} of type @samp{void*}.  It can
point to any event-related information.

@item csevBroadcast
Broadcast events are much like command events, except that no component can
intercept (@emph{eat}) it, and they are feed to all child, grandchild etc.
components in a component tree (starting from the component that received
first this event).
@end table

To check if the event is generated by keyboard, you can use the predefined
@code{CS_IS_KEYBOARD_EVENT(Event)} macro.  To check for mouse events, you can use
the @code{CS_IS_MOUSE_EVENT(Event)} macro.

@node CSWS Clipping, CSWS Tutorial, CSWS Events, CSWS
@subsection Clipping

Clipping is the process of removing parts of output covered by other
components.  @sc{csws} has full clipping implemented for all existing graphics
primitives.  There is no drawing operation that can influence other
component's image except transparent windows.  Clipping is performed in the
following fashion.  First primitive is clipped against @emph{dirty} rectangle
(to cut off excessive output), then it is clipped against all its neighbors,
then against @samp{clip parent} window and all its neighbors and so on.

@subsubheading Clip Parents

All components have a @samp{parent} component and a @samp{clipparent}
component.  What they are used for? Usually @samp{clipparent} is equal to
@samp{parent} so there is no difference between them.  But in some rare cases
there is a need to perform clipping in a different way.  For example, popup
menus that belong to a window usually should not be clipped against that
window, but rather to the parent of parent window or even clipped only to
desktop.  In this case you should assign a different clip parent to that
component.  This can be performed by using @code{InsertClipChild()} method.
For example, to make a menu clip to application's bounds, you should call:

@example
app->InsertClipChild(menu);
@end example

You should not assign directly to @samp{clipparent} variable since
@code{InsertClipChild()} does much extra work.  For example it inserts the
so-called ``clip children'' into component's clip child list, removes
component from former @code{clipparent}'s ``clip children'' list and so on.

@subsubheading Partially Transparent Components

You can set a state flag called @samp{CSS_TRANSPARENT} to mark
semi-transparent components.  Transparent components works differently in the
following ways:

@itemize @bullet
@item
When a part of such a component is invalidated, the same area of parent
component is invalidated as well.

@item
Mouse events for such components are considered ``eaten'' only if component's
@code{HandleEvent()} method returned @samp{true}.  Otherwise, the event is
sent to the component placed below the transparent component.

@item
The output of windows below transparent components is not clipped.  Instead
the area of transparent component covered by output is invalidated so that it
gets redrawn at the end of frame.
@end itemize

@node CSWS Tutorial, , CSWS Clipping, CSWS
@subsection Quick Tutorial

In the following discussion I will try to explain how to build simple
applications using the Crystal Space Windowing System.  I hope you will
understand enough to start writing your own applications; I also hope you will
get a deeper knowledge of @sc{csws} during your development (or lab) sessions.
In fact, I highly recommend perusing the @sc{csws} header files (or
alternatively at the @sc{html} documentation generated from the header files)
as they contain a lot of useful information which is not present here.

@subsubheading A Simple Application

The simplest possible application should do the following:

@itemize @bullet
@item
Start up the typical facilities required by a @sc{csws} application.
@item
Run the application; meaning run the main event processing loop.
@item
Finish the application; that is, shut down.
@end itemize

@noindent
Let's try:

@example
#include "csws/csws.h"

int main(int argc, char const* const argv[])
@{
  iObjectRegistry* object_reg =
    csInitializer::CreateEnvironment (argc, argv);
  if (!object_reg) return -1;

  if (!csInitializer::SetupConfigManager (object_reg,
    "/config/cswstest.cfg")) return -1;

  if (!csInitializer::RequestPlugins (object_reg, CS_REQUEST_END))
    return -1;

  csApp* app = new csApp(object_reg);
  if (app.Initialize())
    csDefaultRunLoop(object_reg);

  delete app;
  csInitializer::DestroyApplication (object_reg);
@}
@end example

Pretty simple, eh?  So the result is simple as well.  We got a gray background,
a mouse and nothing more.  What the program does is:

@itemize @bullet
@item
First of all, it sets up an environment which hosts the Crystal Space and
@sc{csws} facilities.  These are all referenced by the object registry which
is returned from @code{CreateEnvironment()}.

@item
The configuration facility is then set up and instructed to use a particular
configuration file for this application.  The configuration file which contains
the list of all plugins to be loaded, in addition to other things, such as
which textures to use for windowing system components; where on the textures
the respective pictures are placed; and other skin-dependent information.  You
can use the @file{cswstest.cfg} file as a template.  You can also pass @samp{0}
as the file name, in which case you will have to manually tell to the plugin
manager which plug-ins to load (via the @code{csInitializer::RequestPlugin()}
method).  In our case, since we used a configuration file, we do not have to
ask for any additional plugins in the call to @code{RequestPlugin()}, since it
will load all of the ones mentioned by the configuration file.

@item
Second, it creates a @samp{csApp} object called @samp{app}.  To initialize the
application you pass a pointer to the object registry.

@item
The next step is to call @code{csApp::Initialize()}.  You may want to override
this method to initialize your application here (after calling the parent's
@code{Initialize()}).  For instance, create a popup menu, insert it onto the
desktop, add some windows, etc.

@item
And finally we run the main application loop.  The event consuming loop does
the following.  While there are events in input queue it read an event and
dispatches it to interested listeners.  If there were not any events in the
loop, it calls @code{Idle()} method to give some time slices to other running
applications.  If some window needs redrawing, it is redrawn.  After this the
screen is updated and everything starts again from the beginning.
@end itemize

If you observe, the above program allocates the @samp{csApp} object on the
heap, rather than on the stack as an automatic variable.  This is done so that
we can manually destroy that object before @code{DestroyApplication()} is
called.  This is important, because no Crystal Space or @sc{csws} functionality
should be invoked after @code{DestroyApplication()} has been called.  By
destroying @code{csApp} first, we ensure that code in its destructor is invoked
early enough.
