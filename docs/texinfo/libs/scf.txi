@node SCF, csGeom, csUtil, Libraries
@section Shared Class Facility (@sc{scf})
@cindex @sc{scf}, Shared Class Facility
@cindex Shared Class Facility (@sc{scf})

@emph{Original @sc{scf} design and concept by Andrew Zabolotny, 1999.  This
document and Crystal Space's particular @sc{scf} implementation were written,
and are copyright @copyright{} 1999 by Andrew Zabolotny,
@email{bit@@eltech.ru}.  @sc{scf} is distributed under the @sc{gnu} Library
General Public License (@sc{lgpl}).  @xref{License}.}

This library is intended for separating C++ class implementations from
programs that use them; this is achieved by separating class implementations
into a separate module (currently only shared libraries are supported). There
are few requirements of the shared library itself: this helps to address many
problems regarding shared library facility differences encountered on
different platforms. In fact, it is possible to use different mechanisms for
@sc{scf}, for example inter-process communication (through pipes, shared
memory or whatever); communication through network or through a @sc{com} or
@sc{corba} request broker, although currently there are only two minimal
configurations supported: using shared libraries and using static linkage
(for platforms that don't have shared library support).

@sc{scf} is currently part of the @file{csUtil} library.

@menu
* SCF Explained:: How it Works
* SCF Using:: Using @sc{scf}
* SCF Multiple Interfaces:: Classes Implementing Multiple Interfaces
* SCF Versions:: Interface Versions
* SCF Client:: Client Side
* SCF Example:: Example
* SCF Advanced:: Advanced Techniques
@end menu

@node SCF Explained, SCF Using, SCF, SCF
@subsection How it Works

This paragraph contains technical details about @sc{scf}. If you're not
interested in details, you can skip directly to the next chapter which
explains how @sc{scf} should be used from the end-users' point of view.

@sc{scf} is somewhat similar to @sc{com}. This is because historically
Crystal Space initially used @sc{com} for inter-module communications. Thanks
to Dan Ogles for the initial implementation of a cross-platform @sc{com}
library; his implementation was a good testbed for this @sc{scf}
implementation.

The differences between @sc{com} and @sc{scf} are due to the increased need
for an easier-to-use and maybe a more lightweight interface than @sc{com}.
The @sc{com} implementation caused some problems (because of bugs in
@sc{egcs} 1.1.x and incompatibilities with the Objective-C language used by
NeXT). Also it has some problems due to the native Windows types used in
@sc{com}; this experience has been taken into account while developing
@sc{scf}.

The main paradigm of @sc{scf}, as in @sc{com}/@sc{corba}/Java/etc is the
interface. You define an @emph{interface}, that is, a set of abstract methods
that you want to access within some object. @sc{scf} interfaces are plain C++
structs (or classes, it doesn't matter much except that if you're using
classes to which you will have to add the @samp{public:} keyword).
Theoretically interfaces can contain even member variables and inline methods
(but no non-virtual methods and constructors), @emph{but} this practice is
not encouraged because later someone may want to add a @sc{com}, @sc{corba},
etc. layer between the client and the actual object, and this will not be
possible if the interfaces were to contain variables or inline methods. If
you don't plan to use @sc{com} or @sc{corba} later, then you can use
variables and inline functions as much as you like.

Here is an example of an interface:

@example
struct iDog
@{
  virtual bool IsAlive() = 0;
  virtual char const* GetName() = 0;
  virtual void SetName (char const* iName) = 0;
  virtual void Shout(int iHowLoud) = 0;
  virtual void Run(int iSpeed, float iDirection) = 0;
  virtual bool GetChildren(iObjVector* oBrood) = 0;
@};
@end example

Note the last method that gets a pointer of @code{iObjVector} type.
@code{iObjVector} is yet another interface.  We could pass a pointer to an
@code{csObjVector} (the implementation of that interface) as well, but this
will mean both modules (caller and callee) should have same idea about what a
@code{csObjVector} is and if it happened that you compiled the shared library
with a slightly different version of @code{csObjVector} (that, say, had one
member variable fewer) you will end up with a @sc{sigsegv} crash.

Now let's write a particular @dfn{implementation} of the above interface.

@example
#include "idog.h"

class MyDog : public iDog
@{
private:
  @r{@dots{} private member functions & variables @dots{}}
  char* Name;
public:
  virtual bool IsAlive();
  virtual char const* GetName();
  virtual void SetName(char const* iName);
  virtual void Shout(int iHowLoud);
  virtual void Run(int iSpeed, float iDirection);
  virtual bool GetChildren(iObjVector* oBrood);
  @r{@dots{} public member functions & variables @dots{}}
@};

bool MyDog::IsAlive()
@{
  return true;
@};

char const* MyDog::GetName()
@{
  return Name;
@}

void MyDog::SetName(char const* iName)
@{
  if (Name)
    free (Name);
  Name = strcpy (iName);
@}

@r{@dots{} and so on @dots{}}
@end example

Now we put the actual implementation into a separate module (i.e. into a
shared library), and include within the client just the interface file
@file{idog.h}. Now, since the client don't have any idea how we should build
an object of the @samp{MyDog} class, we also provide a function that will
return a newly-allocated object of that class. This is called the
@dfn{class factory} (in fact, a class factory is a bit more than just this,
but more about this later). Here is how to do it:

@example
static iDog* Create_iDog()
@{
  return new MyDog();
@}
@end example

Okay, we did it. Now back to the client. To work with an object that
implements the @samp{iDog} interface we need to load the shared library, get
a pointer to the @code{Create_MyDog()} function, call it and get a new
@samp{MyDog} object. Further we work with this pointer as if it were pointing
to an @samp{iDog} object:

@example
handle = LoadLibrary("libdog.so");
iDog (*Create_iDog)() = GetLibrarySymbol("Create_IDog");
iDog* dog = Create_iDog();
printf("Doggy's name is %s\n", dog->GetName());
dog->Shout(100);
@dots{}
@end example

Of course, you don't have to do all this stuff manually with current @sc{scf}
implementation. The @sc{scf} library provides a number of macros and
functions that almost hides the implementation details from end-user.

@node SCF Using, SCF Multiple Interfaces, SCF Explained, SCF
@subsection Using @sc{scf}

The only include file you need in both your client and server modules is
@file{scf.h}. It contains a number of macros and functions that you will need
for easier use of @sc{scf}. You will also have to add @file{scfimp.cpp} for
both the server and the client, and @file{scf.cpp} for the client.

Some basic functionality of @sc{scf} is provided by a central object. It can
be accessed as @samp{iSCF::SCF} and is of type @samp{iSCF*} (which is also a
valid interface). This object can be accessed from @emph{anywhere}, even from
dynamic libraries. It is used by several parts of @sc{scf}. Note that this
object is only available after calling @code{scfInitialize()}, the main
initialization function of @sc{scf}.

To simplify things, all exported classes are supposed to be derived from some
basical interface called @samp{iBase}. Thus, any interface is supposed to
implement some basical functionality. Currently @samp{iBase} defines three
interface functions:

@table @code
@item void IncRef();
This function should be called each time you get a new reference to a object
and store it for a long-time usage.

@item void DecRef();
Call this function to decrement the object's reference count. When reference
count reaches zero, the object is automatically deleted, provided that it is
not an interface embedded within another object,
@ref{SCF Embedded Interfaces}.

@item iBase* QueryInterface(scfInterfaceID iInterfaceID, int iVersion);
This method will return a pointer to an interface or to an embedded interface,
@ref{SCF Embedded Interfaces}. The @emph{Interface ID} is synonymous to the
name of the interface. In previous versions of @sc{scf} this method used to
accept a string containing the name of the interface. This has been replaced
by the @emph{ID} for performance reasons. You can get the ID for an interface
by using @samp{iSCF::SCF->GetInterfaceID (name)}.
@end table

To simplify things even more, @file{scf.h} provides several macros that
provide default declarations and default implementations of these three
methods. The @samp{SCF_DECLARE_IBASE} macro will declare these three methods
within any class definition that is derived from @samp{iBase}. The
@samp{SCF_IMPLEMENT_IBASE} will add the default implementation of these function
to your module.  Example:

@example
struct iTest : public iBase
@{
  @dots{}
@};

class Test : public iTest
@{
  SCF_DECLARE_IBASE;
@};

SCF_IMPLEMENT_IBASE(Test)
@end example

In reality, we need a few more macros because the @code{QueryInterface()}
function is not static---it depends on the interfaces implemented by given
object. In fact, @code{SCF_IMPLEMENT_IBASE()} defines @code{IncRef()} and
@code{DecRef()} and the beginning of the @code{QueryInterface()} function,
but not the end of that function (i.e. the closing brace). That's because you
have to use an additional macro called @code{SCF_IMPLEMENTS_INTERFACE()} that
will add the code required to support all implemented interface inside the
@code{QueryInterface()}:

@example
SCF_IMPLEMENT_IBASE(Test)
  SCF_IMPLEMENTS_INTERFACE(iTest)
SCF_IMPLEMENT_IBASE_END
@end example

The @samp{SCF_DECLARE_IBASE} macro also defines two member variables:
@samp{scfRefCount} and @samp{scfParent}. @samp{scfRefCount} is the counter
for external references to this object and is used by @code{IncRef()} and
@code{DecRef()} methods. The @samp{scfParent} variable points to the parent
object and is also used by @code{IncRef()} and @code{DecRef()}. Objects are
chained together in a tree-like fashion, and an call to @code{IncRef()} will
also call @code{scfParent->IncRef()}; same with @code{DecRef()}. The root of
the chain is the class factory, that is, an object that is used to create
objects of a specific class. The object tree looks like this:

@example
@r{ClassFactory}
    @r{@result{} Object}
        @r{@result{} Embedded interface}
        @r{@result{} Embedded interface}
            @r{@result{} Sub-embedded interface}
@end example

Thus, if we call the @code{IncRef()} method for @emph{Sub-embedded interface},
we also will increment reference count for @emph{Object} and
@emph{ClassFactory}.

You also should call @code{SCF_CONSTRUCT_IBASE(@var{parent})} inside your class
constructor, this macro will initialize @samp{scfRefCount} to zero and
@samp{scfParent} to @var{parent}. In fact, the constructor of any class
should receive at least one argument of type @samp{iBase*} which should then
be passed along to the @code{SCF_CONSTRUCT_IBASE()} macro.

@node SCF Multiple Interfaces, SCF Versions, SCF Using, SCF
@subsection Classes Implementing Multiple Interfaces

Sometimes we will want one object to implement several interfaces.  For
example, the 3D graphics driver could provide a basic @samp{iGraphics3D}
interface and several additional optional interfaces such as @samp{iHalo},
@samp{iBumpMap}, and so on.  There are two ways to do this:

@itemize @bullet
@item
Via C++ multiple inheritance.

@item
Via object embedding, in which an object that implements another interface is
embedded within the ``carrier'' object.
@end itemize

To simplify the following discussion we'll refer them as @dfn{multiple
interface} and @dfn{embedded interface} methods.

@subsubheading Multiple Interfacing

You can declare a class to inherit from several interfaces at once.  This is
useful if all implemented interfaces will need to access often same member
variables.  For example, both the @samp{iHalo} and @samp{iBumpMap}
implementations will need to access many member variables from
@samp{iGraphics3D} such as pixel format, screen dimensions and so on.  You
declare such classes this way:

@example
class MyGraphics3D :
    public iGraphics3D, public iHalo, public iBumpMap
@{
public:
  @dots{}
@};
@end example

When implementing the methods imposed by the @samp{iBase} interface you should
use the @code{IMPLEMENT_INTERFACE()} macro once for each implemented
interface:

@example
SCF_IMPLEMENT_IBASE(MyGraphics3D)
  SCF_IMPLEMENTS_INTERFACE(iGraphics3D)
  SCF_IMPLEMENTS_INTERFACE(iHalo)
  SCF_IMPLEMENTS_INTERFACE(iBumpMap)
SCF_IMPLEMENT_IBASE_END
@end example

@anchor{SCF Embedded Interfaces}
@subsubheading Embedded Interfaces

Another way to implement several interfaces in one object is to embed an
object that implements some interface into the another object, known as the
``carrier'' object.  This method is preferable when a secondary interface
seldom needs access to the carrier object's members, since you will need to
access them through @code{scfParent} pointer.  Here is an example:

@example
class MyGraphics3D : public iGraphics3D
@{
  // Declare the iHalo embedded interface.
  class MyHalo : public iHalo
  @{
    SCF_DECLARE_EMBEDDED_IBASE(MyGraphics3D);
    @dots{}
  @} scfiHalo;
  // Declare the iBumpMap embedded interface.
  class MyBumpMap : public iBumpMap
  @{
    SCF_DECLARE_EMBEDDED_IBASE(MyGraphics3D);
    @dots{}
  @} scfiBumpMap;

public:
  SCF_DECLARE_IBASE;
  @dots{}
@};
@end example

Note that you don't need to use special names for classes; use anything you
want (that is, the @samp{My} prefix is not required; you could name the above
class @samp{GraphixThreeDeeImplementation} if you like; this is true for
embedded classes as well). But most @sc{scf} macros that have the word
@samp{EMBEDDED} within their names expect embedded object names to follow the
form @samp{scf@var{InterfaceName}}. For instance, @samp{scfiBase},
@samp{scfiTest}, @samp{scfiGraphics3D}, and so on.

When you declare the @samp{iBase} methods within an embedded class, you can
use the @code{SCF_DECLARE_EMBEDDED_IBASE(@var{OuterClass})} macro instead of
@samp{SCF_DECLARE_IBASE}. In this case the @samp{scfParent} member will be of
type @code{@var{OuterClass}*} rather than of type @code{iBase*}; this will
allow the member class to talk with its parent directly, thus allowing for
direct member variables and functions access. In fact, the
@samp{SCF_DECLARE_IBASE} macro uses @code{SCF_DECLARE_EMBEDDED_IBASE(iBase)}.
@samp{SCF_DECLARE_EMBEDDED_IBASE} itself has another special characteristic:
It does not use a reference count, as embedded interfaces may never delete
themselves. @code{IncRef} and @code{DecRef} simply call the corresponding
function of their @code{scfParent}, which is the object they are embedded in.

When using @code{SCF_DECLARE_EMBEDDED_IBASE}, you should implement the
methods with the @code{SCF_IMPLEMENT_EMBEDDED_IBASE()} macro instead of
@code{SCF_IMPLEMENT_IBASE()}.

@example
SCF_IMPLEMENT_IBASE(MyGraphics3D)
  SCF_IMPLEMENTS_INTERFACE (iGraphics3D)
  SCF_IMPLEMENTS_EMBEDDED_INTERFACE(iHalo)
  SCF_IMPLEMENTS_EMBEDDED_INTERFACE(iBumpMap)
SCF_IMPLEMENT_IBASE_END
@end example

And finally, in the parent object's constructor you should initialize all
embedded interface objects with the
@code{SCF_CONSTRUCT_EMBEDDED_IBASE(@var{InterfaceName})} macro.  This will
initialize @samp{scfRefCount} and @samp{scfParent} fields within
@samp{scf@var{InterfaceName}} member variables to appropiate values (zero and
@samp{this}).  Here is how to do it:

@example
MyGraphics3D::MyGraphics3D(iBase* iParent)
@{
  SCF_CONSTRUCT_IBASE(iParent);
  SCF_CONSTRUCT_EMBEDDED_IBASE(iHalo);
  SCF_CONSTRUCT_EMBEDDED_IBASE(iBumpMap);
  @dots{}
@}
@end example

You should not call @code{SCF_CONSTRUCT_IBASE()} within embedded object's
constructor (in fact, it can not have a constructor at all) since all work
needed to initialize @code{iBase} fields is done in the carrier object's
constructor.

@node SCF Versions, SCF Client, SCF Multiple Interfaces, SCF
@subsection Interface Versions

Unlike @sc{com}, @sc{scf} supports interface versions.  That is, a shared
class could implement verion 0.3.6 of given interface, and if client requests
that interface of a version lower or equal than 0.3.6, a correct interface
pointer is returned.  For this to work you need to define inside each
interface header file (typically named @file{i@var{InterfaceName}}) a
constant called @samp{VERSION_i@var{InterfaceName}} that defines the current
version of given interface.  To correctly support different versions of
interfaces you should follow these guidelines:

@itemize @bullet
@item
Do not insert new methods into existing interfaces.  Instead, you should
append them after last defined method.

@item
If your change made the interface invalid for clients that expect older
versions of interfaces (for example, you broke the previous rule), increase
the major version number, and set minor and micro versions to zero.

@item
If your changes are relatively minor, but you do a major release, increase the
minor version number and drop the micro version to zero.

@item
If you're in the developement process, and did a minor change to the
interface, increase the micro version.
@end itemize

The possible range for major and minor version numbers is 0..255, and the
range for micro version number is 0..65535.

When you query an interface, you should always tell it what interface version
are you looking for.  If a module cannot provide an interface compatible with
the requested version, then @code{QueryInterface()} will return @samp{NULL}
(same as if interface wasn't available at all).  You can use
@code{scfCompatibleVersion()} to check whether the requested version is
compatible with interface version. In fact, the @code{SCF_IMPLEMENTS_INTERFACE()}
and @code{SCF_IMPLEMENTS_EMBEDDED_INTERFACE()} macros employ this function.

For easier definition of versioned interfaces you can use the
@code{SCF_VERSION()} macro.

@example
SCF_VERSION(MyGraphics3D, 0, 0, 1);

struct MyGraphics3D : public iBase
@{
  @dots{}
@}
@end example

@node SCF Client, SCF Example, SCF Versions, SCF
@subsection Client Side

Now let's explain how to use all this mess from client side. First, we should
be able to create objects that implements the interfaces we want.  For this,
you should use the @code{SCF_CREATE_INSTANCE()} macro. It receives two arguments:
the name of external class, and the name of the interface it implements. So,
if we know class @samp{MyGraphics3D} implements the @samp{iGraphics3D}
interface, you should write:

@example
iGraphics3D* G3D = SCF_CREATE_INSTANCE(MyGraphics3D, iGraphics3D);
if (!G3D)
@{
  fprintf(stderr,
    "Failed to create an instance of MyGraphics3D!\n");
  abort();
@}
@end example

Now you can use the object any way you like, just like standard C++:

@example
G3D->BeginDraw();
G3D->DrawLine(@dots{});
G3D->DrawPolygon(@dots{});
G3D->EndDraw();
@end example

When you are done using the @samp{G3D} pointer (say, when program exits), you
should free that object by calling @code{G3D->DecRef()}.  After this you can
not use @samp{G3D} anymore; you should create another instance of
@samp{iGraphics3D} for this.

To query an embedded interface, you will want to use the
@code{SCF_QUERY_INTERFACE()} macro. It also receives two arguments, first being
the object you are querying for the embedded interface and second being the
name of the interface you want. Example:

@example
iHalo* halo = SCF_QUERY_INTERFACE(G3D, iHalo);
if (!halo)
@{
  fprintf(stderr,
    "3D graphic driver doesn't support halos!\n");
  return;
@}
@end example

@node SCF Example, SCF Advanced, SCF Client, SCF
@subsection Example

Here is a completely working example. It implements a shared class that has a
base and an embedded interface.

Here are the interface files for the @samp{iDog} interface (the base
interface of our class) and the @samp{iName} interface (the interface
embedded into our class).

@noindent
@emph{File}: @file{idog.h}

@example
#include "scf.h"

// Version number of our interface.
SCF_VERSION(iDog, 0, 0, 1)

struct iDog : public iBase
@{
  virtual void Walk() = 0;
  virtual void Shout(char const* iWhat) = 0;
@};
@end example

@noindent
@emph{File}: @file{iname.h}

@example
#include "scf.h"

// Version number of our interface.
SCF_VERSION(iName, 0, 0, 1);

struct iName : public iBase
@{
  virtual char const* GetName() = 0;
  virtual void SetName(char const* iName) = 0;
@};
@end example

Now here is the implementation of a class for both of the mentioned
interfaces:

@noindent
@emph{File}: @file{dog.cpp}

@example
#include "idog.h"
#include "iname.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

class csDog : public iDog
@{
  char* Name;

  // Embedded interface.
  class csName : public iName
  @{
  public:
    SCF_DECLARE_EMBEDDED_IBASE(csDog);
    virtual char const* GetName();
    virtual void SetName(char const* iName);
  @} scfiName;
  friend class csName;

public:
  SCF_DECLARE_IBASE;
  csDog(iBase* iParent);
  virtual void Walk();
  virtual void Shout(char const* iWhat);
@};

//---------- Implementation ---------

SCF_IMPLEMENT_IBASE(csDog)
  SCF_IMPLEMENTS_INTERFACE(iDog)
  SCF_IMPLEMENTS_EMBEDDED_INTERFACE(iName)
SCF_IMPLEMENT_IBASE_END

csDog::csDog(iBase* iParent)
@{
  SCF_CONSTRUCT_IBASE(iParent);
  SCF_CONSTRUCT_EMBEDDED_IBASE(scfiName);
  Name = NULL;
@}

void csDog::Walk()
@{
  printf("%s: I'm walking\n", Name);
@}

void csDog::Shout(char const* iWhat)
@{
  printf("I'm %s: shout, shout, %s\n", Name, iWhat);
@}

// iName interface for dog.

SCF_IMPLEMENT_EMBEDDED_IBASE(csDog::csName)
  SCF_IMPLEMENTS_INTERFACE(iName)
SCF_IMPLEMENT_IBASE_END

char const* csDog::csName::GetName()
@{
  return scfParent->Name;
@}

void csDog::csName::SetName(char const* iName)
@{
  if (scfParent->Name)
    free(scfParent->Name);
  scfParent->Name = strdup(iName);
@}

// Now export all classes.

SCF_IMPLEMENT_FACTORY(csDog)

SCF_EXPORT_CLASS_TABLE(Dog)
  SCF_EXPORT_CLASS(csDog, "A Dog that shouts")
SCF_EXPORT_CLASS_TABLE_END
@end example

The above three files should be compiled together to get a shared library.
The shared library should export the @code{Create_csDog()} function
(implemented with the @code{SCF_IMPLEMENT_FACTORY()} macro).  On most platforms
this is achieved automatically, however on @sc{os}/2 you will need to write a
@file{.def} file for this.  Finally, here is the source code for a client
application that uses the @samp{csDog} class:

@noindent
@emph{File}: @file{doggy.cpp}

@example
#include <stdio.h>
#include "scf.h"
#include "idog.h"
#include "iname.h"
#include "inifile.h"

int main ()
@{
  csIniFile config("scf.cfg");
  scfInitialize(&config);

  iDog *dog = SCF_CREATE_INSTANCE(csDog, iDog);
  if (!dog)
    fprintf(stderr, "No csDog shared class!\n");
  else
  @{
    iName* name = SCF_QUERY_INTERFACE(dog, iName);
    if (!name)
      fprintf(stderr,
        "Dog does not support iName interface!\n");
    else
    @{
      name->SetName("Droopy");
      dog->Walk();
      dog->Shout("hello!");
      printf("Dog's name is %s\n", name->GetName());
      name->DecRef();
    @}
    dog->DecRef();
  @}

  iSCF::SCF->Finish();
@}
@end example

Now the last thing: @sc{scf} uses a file called @file{scf.cfg} for storing
the @var{class name} to @var{shared library name} mapping. The file's format
is simple: @samp{@var{ClassName} = @var{SharedLibraryName}}. So, for the
above example to work you have to add a line that reads @samp{csDog = dog} to
the @code{[SCF.Registry]} section of the configuration file @file{scf.cfg}.

Alternatively, you can register classes at run time:

@example
iSCF::SCF->RegisterClass("csDog", "dog");
@end example

@node SCF Advanced, , SCF Example, SCF
@subsection Advanced Techniques

The @sc{scf} library implements some things that you will need to know about
to use some advanced techniques.  They are described in detail, below.

@subsubheading @code{QueryInterface()} performance

Usually you use @code{SCF_QUERY_INTERFACE (object, interface)} to query an
interface from an object. However, this involves string comparison and should
therefore be considered slow. To speed things up, place the following line
somewhere in your source file (header files are also allowed, as this only
defines an inline function):
@example
SCF_DECLARE_FAST_INTERFACE (iInterfaceName)
@end example
After that, you can use @code{SCF_QUERY_INTERFACE_FAST (object, interface)}
to query an interface from an object.

@subsubheading Dynamic Class Registration

You can register and deregister @sc{scf} classes at run time.  You can even
dynamically replace one class with another if you use same @sc{id} during
registration.  There are two functions that can be used to dynamically
register classes; one for registering classes in shared libraries and one for
registering classes within client module. To register a class that is located
inside a shared library, use this function:

@example
bool iSCF::RegisterClass(
    char const* iClassID,
    char const* iLibraryName);
@end example

The prototype should be self-describing. As any method of @code{iSCF}, you
should call the function as @samp{iSCF::SCF->RegisterClass()}. If you have a
class that is linked into the executable, you should prepare a structure of
the @samp{scfClassInfo} type and pass it to the following function:

@example
bool iSCF::RegisterClass(scfClassInfo*);
@end example

You should fill the @samp{ClassID} and @samp{Factory} fields.  The
@samp{Description} field is not used except by the @file{scfreg} utility.

You can deregister an already registered class with the following function:

@example
bool iSCF::UnregisterClass(char const* iClassID);
@end example

@subsubheading Non-Registered Classes

Sometimes you don't want to register your classes with the @sc{scf} kernel.
That is, you create your objects manually, using @samp{new} or some other
method.  In this case your object is not a part of the class tree (see above)
and thus doesn't have a parent.  In this case you have to pass @samp{NULL} to
the @code{SCF_CONSTRUCT_IBASE()} macro in constructor.

@example
MyClass::MyClass()
@{
  SCF_CONSTRUCT_IBASE(NULL)
@}
@end example

If you also want your object to not be automatically deleted when the
reference count reaches zero, you can use @code{SCF_IMPLEMENT_EMBEDDED_IBASE()}
instead of @code{SCF_IMPLEMENT_IBASE()}, as if your object was an embedded
interface.  Embedded interfaces don't have the habit of deleting themselves
when their reference count reaches zero.  In this case you should take care
and delete your object manually.
