@c -*-texinfo-*-
@node csPhyziks, , CSWS, Libraries
@section csPhyziks Library (@code{csphyzik})
@cindex Phyziks
@cindex csphyzik
@cindex Libraries, csphyzik

@noindent
@emph{Written by Michael Alexander Ewert, @email{michael_ewert@@hotmail.com}.
Last updated 22 July 2000.}

This library is a work in progress so many things will change (and probably
already have by the time you read this).

The Phyziks (@file{csphyzik}) library is a dynamics modeling and simulation
engine.  Focus is currently on rigid body dynamics.  The core of the engine is
a numerical integrator that solves the equations of motion for given bodies.
Different types of bodies will have different equations of motion.  A simple
example would be the equations of motion for the center of mass of a rigid
body.

These two equations together have a fancy name: @dfn{Coupled Ordinary
Differential Equations}.

@table @code
@item dx/dt = v
Change of the bodies position over time @equiv{} the velocity of the body.
@item dv/dt = a
Change in velocity @equiv{} acceleration.
@end table

This equation is used to bootstrap the solving of the above @sc{ode}s:

@table @code
@item F = ma
Force = mass * acceleration. So @code{a = F/m}. Plug into second @sc{ode}.
@end table

You would add the body to the engine and any forces that act on it.  When
you tell the engine to evolve the system, it will figure out the new value
for the state of your body.  Then you would request the new position from
the engine via a pointer to your body.  That value would be used to
update the position of the object that represents your body in the renderer.

@menu
* csPhyziks World:: Physical World
* csPhyziks Bodies:: Bodies
* csPhyziks Forces:: Forces
* csPhyziks Articulated Bodies:: Articulated Bodies
* csPhyziks Impulses:: Impulses
* csPhyziks Solvers:: Solvers
* csPhyziks Evolve-Collide-Update Loop:: Catastrophes
* csPhyziks ODE Solvers:: @sc{ode} Solvers
* csPhyziks Usage Guide:: Usage Guide
@end menu

@node csPhyziks World, csPhyziks Bodies, csPhyziks, csPhyziks
@subsection Physical World

There is a convenient header file that includes all the other headers you
will probably need.

@example
#include "csphyzik/phyziks.h"
@end example

The main object used to represent the physics engine is @samp{ctWorld}.

@example
ctWorld phyz_world;
@end example

Any bodies you want to be dynamically simulated need to be added to a
@samp{ctWorld}.

@example
phyz_world.add_rigidbody(a_rigid_body_pointerd);
@end example

You can add forces that will affect all bodies the system by adding an
environmental force:

@example
phyz_world.add_enviro_force(gravity_force_pointer);
@end example

When you want to evolve the system simply do this:

@example
phyz_world.evolve(time_start, time_end);
@end example

Now the rigid body we added should have been moved by the gravity force.

@node csPhyziks Bodies, csPhyziks Forces, csPhyziks World, csPhyziks
@subsection Bodies

The inheritance hierarchy for bodies looks something like this:

@example
ctPhysicalEntity
    @result{} ctWorld
    @result{} ctArticulatedBody
    @result{} ctDynamicEntity
        @result{} ctSoftBody
        @result{} ctRigidBody
@end example

Here is a brief summary of the various bodies:

@table @code
@item ctPhysicalEntity
A body with position and velocity.  Any body inheriting from this can be added
to a world.
@item ctArticulatedBody
A body that in composed of a number of rigid bodies connected via joints.
@item ctDynamicEntity
A body that has mass.
@item ctSoftBody
@emph{Not implemented}.
@item ctRigidBody
A rigid body with rotational state and an inertia tensor.
@end table

Let's look at @samp{ctRigidBody}.  Probably the most common type of body.  Any
solid object without moving parts is most likely a rigid body.  The best way
to create one and add it to a world is like so:

@example
ctWorld phyz_world;
ctRigidBody* rb = ctRigidBody::new_ctRigidBody();
phyz_world.add_rigidbody(rb);
@end example

@noindent
This will set up reference frame correctly.  Creating a rigid-body with the
C++ @samp{new} operator will not do so.

Now you need to specify some properties: position, mass, and an inertia
tensor.  @emph{Note}: Be sure you set the mass before calculating the
@samp{I_tensor}, since @samp{I_tensor} is dependent upon mass.

@example
rb->set_m(15.0);       // Set mass.
rb->set_pos(0, 10, 0); // Set position.
// Defaults to zero if you omit following step.
rb->set_v(ctVector3(1, 0, 0));
// Calculate inertia tensor of a rectangular block.
rb->calc_simple_I_tensor(0.2, 0.4, 0.2);
@end example

That last step will calculate an inertia tensor for a solid rectangular block
of uniform density, with dimensions of width 0.2, height 0.4 and depth 0.2
(x,y,z).  An inertia tensor is used to calculate the response to angular
forces and impulses.  Every shape of object has a different type of inertia
tensor.  You must set a mass before you specify the inertia tensor.

You can set the orientation of the body directly (by setting the
transformation matrix), or like so:

@example
// Axis around which to rotate body.
ctVector3 rotaxisxy(1, 1, 0);
rb->rotate_around_line(rotaxisy, degree_to_rad(45));
@end example

Angular velocity is specified by a vector that points in the direction of the
axis of rotation.  The magnitude of that vector determines how fast it
rotates.

@node csPhyziks Forces, csPhyziks Articulated Bodies, csPhyziks Bodies, csPhyziks
@subsection Forces

There are many types of forces that can be used.  More are easy to add as
well.  The three main types are environmental forces, N-body forces, and
simple forces.

Environmental forces are added to a @samp{ctWorld} and act on all bodies in
that world, for example gravity, air resistance, etc.

@example
ctGravityF* gf = new ctGravityF(9.81 / M_PER_WORLDUNIT);
phyz_world.add_enviro_force(gf);
@end example

N-body forces are forces that act between multiple bodies, for example springs
and planetary gravity.

@example
ctVector3 spring_attachment_point1(0, 1, 0);
ctSpringF* sf = new ctSpringF(
    rb1, spring_attachment_point1,
    rb2, spring_attachment_point2);
sf->set_magnitude(200.0 / M_PER_WORLDUNIT);
// Need to add force to each body it affects.
rb1->add_force(sf);
rb2->add_force(sf);
@end example

Specify the second body as @samp{NULL} to indicate that end is attached to
the world and is therefore immovable.

Simple forces would be something like a rocket engine or other kind of force
that only acts on one body.

@node csPhyziks Articulated Bodies, csPhyziks Impulses, csPhyziks Forces, csPhyziks
@subsection Articulated Bodies

An articulated body is a rigid body that can have one or more other rigid
bodies connected to it by joints.  Such as a chain or a human figure.
Currently revolute (like a hinge) joints and prismatic (like an air pump)
joints are implemented.  Also the articulated body can not at present have any
closed loops in it.  Articulated bodies can have one end fixed immovably to
the world reference frame, be free floating, or be attached to an entity whose
movement is specified by the user.

@example
// Use new_ctRigidBody makes sure the rb will have
// a suitable reference frame.
rb = ctRigidBody::new_ctRigidBody();
// Create an articulated body with a rigid body.
ab_parent = new ctArticulatedBody(rb);
// Only have to add the root; no need to add
// children to world.
phyz_world.add_add_articulatedbodybase(ab_parent);

ab_child = new ctArticulatedBody(rb2);
ctVector3 joint_offset_parent_to_child(0, -0.1, 0);
// Line of action for this joint.
ctVector3 joint_action(0, 0, 1);
// Link the child to the parent with a revolute joint.
ab_parent->link_revolute(
  ab_child,
  joint_offset_parent_to_child,
  joint_offset_ctop,
  joint_action);
@end example

Now when evolved the articulated body will move in a dynamically correct
manner in response to any external and internal forces (if the Featherstone
solver is used).

It is possible to define your own joints from @samp{ctJoint}.  You can then
overload the @code{get_actuator_magnitude()} method to implement a joint with
a motor that will exert whatever force you like at that joint.  There is such
a joint implemented that enforces angle constraints on the joint,
@samp{ctConstrainedRevoluteJoint}.  Add this joint using:

@example
parent_ab->link_joint(new_constrained_joint, child_ab);
@end example

You can set the angles that joint is constrained to using:

@example
set_constraint(max_angle, min_angle);
@end example

Test out your joint and modify the spring and damping constants to get the
proper behavior.  For instance, if your joint bounces back too much at the
constraint, your spring constant is too high.

You can attach the root of an articulated body to some object from your own
side of the code.  The attached articulated body's root will move however you
specify and the correct physical behavior will result for the rest of the
artibulated body.

Do this by subclassing @samp{ctKinematicEntity} and implementing all its
methods.  (Minimally, you need to implement @code{get_a()}.) These methods
tell the physics module how your object moves.  You can use this to attach
hair, or a chain, or whatever you like to your game characters.  After you
create your subclass, you attach your articulated body root to it with:

@example
abroot->attach_to_entity(&your_kinematic_entity);
@end example

Make sure you have grounded your root first with
@code{abroot->make_grounded()}.  Now if you want to detach that chain you
should just be able to call @code{abroot->make_ungrounded()}.

@node csPhyziks Impulses, csPhyziks Solvers, csPhyziks Articulated Bodies, csPhyziks
@subsection Impulses

An impulse is a large force applied over a very short time interval.  Such as
in a collision or an explosion.  Impulses should be applied to a body any time
before or after, but not during an evolve process.

@example
rb->apply_impulse(
  vector_direction_of_impulse_with_magnitude,
  vector_location_of_impulse_in_world_coords);
@end example

@node csPhyziks Solvers, csPhyziks Evolve-Collide-Update Loop, csPhyziks Impulses, csPhyziks
@subsection Solvers

Every object has a solver that represents the algorithm used to help calculate
its change in state each time step.  A @samp{ctPhysicalEntity} or any of its
subclasses can change what solver it uses at any time.

@node csPhyziks Evolve-Collide-Update Loop, csPhyziks ODE Solvers, csPhyziks Solvers, csPhyziks
@subsection Catastrophes

A @dfn{catastrophe} is an event where there is a discontinuity in the system
and the @sc{ode} solver can't cope with it.  So you need to resolve the
catastrophe situation before the system can be evolved any further.  The main
catastrophe event (actually the only one used in most rigid-body simulations)
we deal with is a collision.  So I use the terms @dfn{catastrophe} and
@dfn{collision} interchangeably here.

@subsubheading Setting Up a Collision Catastrophe

@emph{Note}: There is no collision detection capability in @samp{csphyziks}.
Ben Sprague has been making good progress on one and hopefully it will be
integrated in the future.  @sc{solid} is a pretty decent @sc{gpl} collision
detection engine that works well for colliding contacts, although it requires
a few more features before it can be used for resting contact.

First thing you need to do is subclass @samp{ctCatastropheManager} and
implement @code{check_catastrophe()} which returns a value greater 0 if there
was a catastrophe, and @code{handle_catastrophe()} which will be called when
the simulation has been backed up to a point just before the first catastrophe
was encountered (within the catastrophe defined epsilon of time).  Then you
add your @samp{ctCatastropheManager} to the world using:

@example
ctWorld::register_catastrophe_manager(
  ctCatastropheManager* your_cat_manager);
@end example

Now every time you call @code{ctWorld::evolve(real t1, real t2)} it will
make a callback to @code{check_catastrophe()} where you do your collision (or
whatever) check using the position and orientations of the rigid bodies at
that time.  If there was a collision, keep track of what objects collided and
return the maximum interpenetration distance (or just a number greater than 0
if you like).  If there was no collision return 0.  Now the physics engine
will rewind the state of the system and call @code{check_catastrophe()} again,
and repeat until you finally return 0, indicating there was no catastrophe.

Now the physics engine will make a callback to @code{handle_catastrophe()}
where you must resolve all catastrophes that occurred during the most recent
call to @code{check_catastrophe()}, so you need to maintain a list of those
objects that collided last check.  In the case of resolving collisions you
need to fill out a @samp{ctCollidingContact} object and pass it to
@code{ctWorld::resolve_collision()} for each collision, which will apply an
impulse to both bodies and send them on a path away from each other.

A couple of things need to be explained.  The collision normal and contact
point must be figured out by the collision detection routines, which are not
part of the @samp{csphyziks} library.  The collision normal is the vector that
specifies what component of the objects momentum to bounce back.

The collision normal is calculated once you know what features of each object
collided.  If it was a vertex or edge of one object hitting a face of another
object, the collision normal is just the normal of that face.  If it is an
edge-edge collision the normal is the cross-product (normalized) of those two
edges.  Or you can just take a best guess if you don't have a very accurate
collision detection system.

To find the exact time of collision involves rewinding the @samp{csphyziks}
simulation and trying with smaller time steps until @samp{csphyziks} has
reached a minimum collision distance.  This can be quite a time-consuming
process.

The collision response code does not accurately handle multiple points of
simultaneous collision on one object.

@node csPhyziks ODE Solvers, csPhyziks Usage Guide, csPhyziks Evolve-Collide-Update Loop, csPhyziks
@subsection @sc{ode} Solvers

An @sc{ode} is an @dfn{Ordinary Differential Equation} solver.  @samp{ctWorld}
starts out with a default @sc{ode} solver of Runga-Kutta order 4.  This is a
fairly good one for stability and has only a moderate performance hit.

If you notice your objects freaking out and disappearing (usually by flying
off into space), you probably have a stability problem.  Springs with high
constants (stiff) are a classic for stability problems.

If you need either more speed or more stability, you may want to use a
different one.  Improved stability means decreased performance and vice versa.
Basically improved stability is gained by more complete evaluations of the
whole system per time step (call to evolve).

The problem is that the slower your frame-rate is, the bigger time steps the
dynamics solver will be solving for.  Big time steps contribute to instability
as well.  So you can try to fix instability by using a more sophisticated
@sc{ode} solver like Runga-Kutta with adaptive step sizing (not yet
implemented), but the resulting performance hit could cause more instability.
So it can be a no-win situation when choosing and @sc{ode} solver if you have
a very low frame-rate.  Then it's time to up the system requirements of your
application.

@node csPhyziks Usage Guide, , csPhyziks ODE Solvers, csPhyziks
@subsection Usage Guide

The way you use this physics module in your application is very application
specific.  Since games are the most common type of application this section
will mostly cover recommended usage for games.

If your game is a space-ship type game, I would recommend putting all your
game objects under primary control of the physics engine.  Thrown in some
gravity wells for planets, subclass @samp{ctForce} to create your rocket
engine, add a rigid body for each game object, apply impulses when something
gets hit and things should work out well for you.

If your game has animated models running around and blowing each other up or
running obstacle courses, you probably do @emph{not} want to put everything
under control of the physics module.  I would recommend using the physics
module for special effects and appropriate game-play objects.  For instance,
attach a tail to your character as an articulated body, use rigid bodies for
gibbs or explosion debris, have an articulated body for your characters that
only gets activated when you want them to act like a rag-doll, use articulated
bodies for ropes that your char can swing on, trees that sway in the wind,
etc.

I would recommend using several @code{ctWorld}'s that isolate distinct element
from each other, so that during a catastrophe time-slicing search your whole
simulation doesn't bog down.  For instance, have one @samp{ctWorld} for all
your debris and body parts, if you have a tail on your main character add that
as an articulated body to its own @samp{ctWorld}.

@subsubheading Caveats

This module is a tool, and used properly, could really enhance the reality of
your game worlds.  You need to control and interpret the results to make sure
they make sense and are consistent with your games behavior.

At the time of writing, continuous contact with the ground is only partial
implemented (the solver exists).  This is a pretty important feature, and its
absence limits what you can do with this module.  However the main tools;
impulse response (rigid body and articulated body), grounded articulated
bodies and @samp{ctKinematicEntity} attached articulated bodies.  These
features are sufficient for many nifty dynamically controlled elements.
