@c -*-texinfo-*-
@node Tutorial Introduction, Tutorial Simple, Tutorials, Tutorials
@section Developing a Crystal Space Application

Crystal Space is a package of components and libraries which can all be useful
for creating computer games.  Although some of the packages are intended more
for 3D gaming this is not as such a restriction of the package.  Components as
the sound driver function just as well in a 2D gaming environment and the
networking component can even be used in a text oriented environment.  This
highlights one of the important characteristics of Crystal Space: the
components and libraries are more or less independent of each other.  If you
don't want networking, then just don't use the networking drivers.  If you
don't want scripting then don't include that.  All packages are designed to be
functional on their own or with a minimal number of other packages.  There are
some dependencies of course.  For example, the 3D Engine requires a 3D
Rasterizer to display its output.  On the other hand, you could very well use
the 3D Rasterizer without the 3D Engine.

Although there is a high level of independence, there is also a high level of
integration.  The components and libraries were also designed to be used
together and as such offer a flexible scheme of integration.

If you are interested in developing a program using Crystal Space, then it is
important to understand that Crystal Space is not a single monolithic library,
but instead consists of several @dfn{libraries} and @dfn{plug-in modules}.
This manual uses the term @dfn{module} for both libraries and plug-ins when
the distinction between the two is not important.

A plug-in module is similar to a library, but has some advantages over a
library.  All plug-ins can be accessed in a common fashion.  They have a
@emph{very} clear interface, and they can provide this interface even if they
are extracted to a DLL.  So they are the better solution as long as speed is
not the dictator of all decisions as in the math library (access to plug-in
functions uses virtual methods).  The main difference between the interface of
a library and a plug-in is that a library may use @sc{scf} and C++ classes;
plug-ins may only use @sc{scf}.

@itemize @bullet
@item
What is @sc{scf}?

The main @sc{scf} object is the @emph{Interface}.  An interface is the
solution to strictly decouple the public methods of an object from their
implementation.  You only get a pointer to an abstract class with only virtual
methods, called the interface, so your program doesn't know about the actual
object behind the pointer.  This object is called an @emph{Implementation} of
the interface.  You as the user of Crystal Space will call functions that
create the actual object, but only return the interface.  After that you can
use the interface like a C++ object.  When you don't need it anymore, don't
@samp{delete} it, but call @code{DecRef()}.  When you pass a pointer to the
interface to anywhere, call @code{AddRef()} from there, and @code{DecRef()}
when you don't need the interface there anymore.

As the user you'll only have to include a header that defines the interface,
but not the implementation.  Despite the obvious advantage of having a very
clear structure in your code, there is the advantage that linking the
interface to the implementation can be done at run-time, but more about this
later.

@item
What are the characteristics of a library?

A library is just a normal C++ library as you know them.  A library can
optionally provide @sc{scf} interfaces.  In the case of a library this is just
a way to define a clear structure.  But as their main interface, libraries
provide C++ classes.

@item
What are the characteristics of a plug-in?

A plug-in, on the other hand, will only provide @sc{scf} interfaces, no normal
C++ classes. The plug-in itself will also appear as an @sc{scf} interface.
This is part of the definition of a plug-in.  A plug-in can be organized as
static library or @sc{dll}; this only makes a small difference in how you use
it in your program.

As the user of Crystal Space, you have to do
the following steps to use a plug-in:

@itemize @minus
@item
First, do all these steps for the dependencies (other plug-ins) that this
plug-in relies on.

@item
Register the library that contains the plug-in.

@item
Load the plug-in.  This will also initialize the plug-in.  It will fail if you
forgot any dependencies.

@item
Query the plug-in interface.  This is an @sc{scf} interface, so you now have
access to the functions of the plug-in.
@end itemize

@item
How can I register the plug-in library?

@dfn{Registering} means to tell @sc{scf} the name of the plug-in that was
given to it by its author, and a class or a dynamic library to associate it
with. For example, to use the software graphics driver you must tell @sc{scf}
that the plug-in with the name @samp{crystalspace.graphics3d.software} can be
found in @file{soft3d.dll} or @file{soft3d.so}. Actually the extension will
be added automatically, so you just have to use @file{soft3d} as the name of
the library. You can find examples for this in @file{scf.cfg}.

How you must register a library depends on whether it is a static library or
a dynamic library (@file{.dll} or @file{.so}). For a static library, put this
line at toplevel into one of your C++ files and link to the static library:
@example
SCF_REGISTER_STATIC_LIBRARY(@var{name})
@end example
This will register all plug-ins in the statically-linked library @file{name}.
This name is chosen by the author of the library. In the case of static
libraries, it may be different from the filename of the library.

For a dynamic library, use @samp{scfreg} at your command line:
@example
scfreg @var{name}.dll    # @r{For Windows or @sc{dos}}
scfreg lib@var{name}.so  # @r{For most Unix platforms}
@end example
This will register all plug-ins in the specified dynamic library. Dynamic
libraries need to be registered only once as long as you do not modify the
library itself. The information is then stored in @file{scf.cfg} (that's why
you can find examples of plugin-to-library association in this file).

@item
How can I load the plug-in?

To load a plug-in, you must tell the system driver two things: The first
thing is the name of the plug-in as it was registered in the previous step.
The second name is the so-called @dfn{functionality identifier}. This
identifier is used to access the plug-in from your program. You could for
example load the software graphics module with the identifier
@samp{GFXDriver}. When you want to use the driver in your program you ask the
system driver for the plug-in with this identifier.

Of course you may not load any driver at this identifier. For example, it
doesn't make sense to load a sound driver and then use it as a graphics
driver. Here we come back to the concept of @sc{scf} interfaces: All graphics
drivers use one interface, and all sound drivers use one interface, but
graphics and sound use different interfaces. Now you have loaded a driver
with the @samp{GFXDriver} identifier. In your program, you actually ask for a
plug-in that is loaded with this identifier @emph{and} implements the
interface of the graphics driver. Alternatively, you may also search all
identifiers for the first plug-in that implements the graphics driver's
interface.

If you loaded the sound driver instead, it doesn't implement the graphics
interface, so you can't use it. To your program this looks like if no driver
was loaded at all for this identifier.

Note that the decision which graphics driver you use (e.g. Software or
Direct3D) is done at the time you load the plug-in by passing the name of
that driver. At the time you ask for the plug-in interface and use use it in
your program, this does not make a difference anymore. This makes it possible
to exchange the driver simply by loading another driver, but without changing
your main program.

The CS modules themselves look for some standard plug-ins at standardized
identifiers. For example, the 3d engine looks for the graphics driver at the
@samp{VideoDriver} identifier. So the engine will only work correctly if you
use these standardized identifiers for the drivers. These are:

@table @code
@item VFS
the virtual file system

@item VideoDriver
standard graphics output

@item SoundRender
standard sound output

@item NetDriver
network driver

@item Console
the console

@item Engine
the 3d engine
@end table

Now how can you actually load the plug-in if you know the functionality
identifier and the name? There are three ways how to do this (they can also
be mixed). The first way is to add the following line in the @code{[PlugIns]}
section in your config file: @samp{@var{FuncID} = @var{PluginName}}. This is
used in most cases.

The second way is to call
@code{@var{SystemDriver}->RequestPlugin("@var{PluginName}:@var{id}")}.
You must do this before calling @code{YourSysDriver->Initialize()}. If you
use this method, you may also load the plug-in without a functionality
identifier, but then you will only be able to use it if you search through
all identifiers for an interface. You can do this with
@code{@var{SystemDriver}->RequestPlugin("@var{PluginName}")}.
This way the name of the plug-in is just hardcoded, not stored in a config
file. This can be used if you know that you will always need these plug-ins.

At the time you call @code{SystemDriver->Initialize()}, all requested plugins
are loaded. As said before, there are dependencies between the plug-ins, i.e.
some plug-ins require others to work. Because of this, plug-ins are sorted
in the correct order before they are loaded, so that if a plug-in is
required by another, the first one is loaded first, no matter whether it
appears first in the config file (or in the first @code{RequestPlugin} line).
@emph{Note that this function does not work correctly yet, because it
requires all plug-ins to correctly say which plug-ins they rely on, which only
a few plug-ins do at this time.}

The third possibility to load a plug-in is to use @code{CS_LOAD_PLUGIN()}.
This can also be used after the system was initialized. The disadvantage is
that a plug-in loaded this way is not included in the sorting process
described above. So you must make sure that all plug-ins required by the one
you want to load are already loaded at the time you use this. Also, if you
use this function there is no need to query the plug-in anymore, as
@code{CS_LOAD_PLUGIN()} directly returns the plug-in interface.

@item
How can I query the plug-in interface?

This is the last step before you can use the plug-in. It means that inside
your program you ask the system driver for the plug-in interface:
@code{CS_QUERY_PLUGIN_ID(@var{SystemDriver},@var{FuncID},@var{iInterface})}.
This macro returns the pointer or NULL if the interface is not found. If you
want to search through all identifiers for an interface, you can use
@code{CS_QUERY_PLUGIN(@var{YourSysDriver},@var{iSomething})}.

@item
Conclusion

To sum it up, @sc{scf} is mainly used to provide common interfaces for
@sc{dll}s, but it can also be used by statically linked libraries.  If you
want to know how to write a plug-in yourself, you should read the complete
@sc{scf} documentation.  @xref{SCF}.
@end itemize

For further information about modules and plug-in drivers, see the sections
on Libraries (@pxref{Libraries}) and plug-in modules
(@pxref{Plug-In Drivers}).

Now that you have learned some basics about the Crystal Space environment,
you can try writing your first program.
