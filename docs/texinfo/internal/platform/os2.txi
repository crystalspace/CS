@c -*-texinfo-*-

@macro OSTWO{}
@sc{os}/2
@end macro

@node OS2 Details, , NeXT Details, Platform Details
@subsection OS/2
@cindex OS/2 Details

@noindent
@emph{Written by Andrew Zabolotny, @email{bit@@eltech.ru}.}

The @OSTWO{} port of Crystal Space has a number of specific features that
should be mentioned, so that you can better understand sourcecode and/or make
modifications, if you need them.  If you do, you should make them available to
the public, as stated by the @sc{lgpl}.  @xref{License}.

If you have any problems or questions related to @OSTWO{} port, mail them to
Andrew Zabolotny (@email{bit@@eltech.ru}).  Configuration, compilation, and
installation instructions for the @OSTWO{} port are also available, @ref{OS2}.

You also may want to check the @sc{pgcc} for @OSTWO{} home page which
Andrew maintains.

@uref{http://goof.com/pcg/os2}

@noindent
Using @sc{pgcc} is recommended since it better optimizes for Pentium and alike
than regular @sc{gcc}.

@menu
* OS2 DIVE:: @sc{dive}
* OS2 DIVE Features:: @sc{dive} Features
* OS2 Input:: Mouse and Keyboard
* OS2 Crashes:: Mysterious Crashes
@end menu

@node OS2 DIVE, OS2 DIVE Features, OS2 Details, OS2 Details
@subsubsection @sc{dive}
@cindex @sc{dive}
@cindex @sc{os}/2 @sc{dive}

The current implementation requires @sc{dive}, so the application is compiled
as a @sc{pm} application.  This is done by default (@file{os2link.cmd}
creates automatically a @file{.def} file).  If you want to compile the
application as a console application, you have to link it with the
@code{$(DO.LINK.CONSOLE.EXE)} macro (have a look at
@file{apps/scfreg/scfreg.mak}).

Other thing you should keep in mind is that @sc{dive} library
(@file{libDIVE.cpp}) uses a couple of resources, so you should not forget to
link the resources to your application.  Resources can be found in
@file{libDIVE.rc}; this is added to linker dependencies for @sc{pm} programs
in @sc{csdive} driver makefile, so you also don't need to worry about it (but
is still useful to know).

There is one not too pleasant feature related to @sc{dive} (or to acceleration
hardware specifics?).  If @sc{dive} image should be rescaled (i.e.  the scale
ratio is not 1:1) @sc{dive} is almost @emph{twice} as slow if @sc{dive} window
(the client rectangle, not the window border) is not on a two-aligned bound
(at least such an effect I've got on my Matrox Mystique).  If you get low
frame rates, try moving the window by one pixel left/right.

To fix this if you use @samp{Video.WindowX} and @samp{Video.WindowY} keywords
in the application's configuration file (such as @file{walktest.cfg}) or use
@samp{-pos <@var{x}>x<@var{y}>} command-line switch, the computed @sc{x} value
will be rounded to nearest divisor of 2.  However, if you manually move the
window it can fall on a odd bound and you'll get twice lower frame rates.

You can use @samp{Video.WindowWidth} and @samp{Video.WindowHeight} keywords in
the configuration file to define start window width and height (client window
width and height, not counting borders and titlebar).  If you won't define it,
the @sc{dive} window will be rescaled to the maximum possible integer factor
such that window won't be larger than screen.  For example, a 320x200 window in
1152x864 resolution will be automatically rescaled at startup to 960x600.

@node OS2 DIVE Features, OS2 Input, OS2 DIVE, OS2 Details
@subsubsection @sc{dive} Features

Here is a short list of implementation features related to @sc{dive}:

@itemize @bullet
@item
@sc{dive} contexts can be created with following pixel formats:

@itemize @minus
@item
@code{FOURCC_LUT8}
@item
@code{FOURCC_R565}
@item
@code{FOURCC_R664}
@item
@code{FOURCC_R555}
@item
@code{FOURCC_BGR4}
@end itemize

If you use @samp{DEPTH=8} in Crystal Space configuration file, or use
@samp{-depth 8} command-line parameter, Crystal Space will start with
@samp{FOURCC_LUT8} pixel format, regardless of what @sc{pm} screen depth you
have.  If you choose 15, 16 or 32 bit color depth, the format will be chosen
as follows:

@itemize @minus
@item
If you selected 32-bit mode, and current screen depth is 32 bits, current
pixel format is used.  See the following note for more information.

@item
If screen pixel depth is @samp{FOURCC_R565}, @samp{FOURCC_R664},
@samp{FOURCC_R555}, that pixel format is used.

@item
If you use @samp{-depth 15} or @samp{DEPTH=15} parameters, @samp{FOURCC_R555}
pixel format will be used.

@item
Otherwise the list of @sc{dive} supported pixel formats is scanned.  The most
wanted mode is R5-G6-B5 mode, if it is not available R6-G6-B4 mode is choosen,
if it is not available, R5-G5-B5 mode is choosen.  If no 16- or 15-bit mode is
available, code falls back to 256-color mode.
@end itemize

@emph{Note}: Due to a bug (or a misimplemented feature, to say so) in @OSTWO{}
@sc{dive} library, you can't use 32-bit modes with the stock @file{DIVE.DLL}
library.  You have to patch it first so that it won't reject @samp{BGR4} pixel
format when creating image buffers.

@strong{Warning}: This is a @emph{Bad Fix} however I didn't have any other
choice.  It works for me with Matrox Mystique and Matrox Millenium ][ video
cards, but I don't guarantee it will work for you:

Go to @file{\MMOS2\DLL}. Take the @file{DIVE.DLL} library. Unpack it, if it
is packed (@samp{lxlite /x dive.dll}). Now find the following sequence of
bytes inside it:

@example
83 C2 08 41 83 F9 [10]
@end example

This sequence happens only once in my @file{DIVE.DLL}; I hope this is true for
your @file{DIVE.DLL} as well.  Now change the @samp{10} that I took into
square brackets with @samp{16}.  That's all.

Note that you will likely get wrong results if your current pixel format is
@emph{not} low-endian 32-bit (i.e. @samp{BGR4}).  That's not my fault.

@item
@sc{dive} windows can be rescaled to arbitrary sizes.  Rescaling is done
automatically by @sc{dive}, as well as color conversion.  Note that if
En@sc{dive} is available, you better use the same pixel format as your @sc{pm}
does, since most cards (my Matrox Mystique, for example) supports in hardware
@emph{either} color conversion @emph{or} rescaling, but not both (although I
can be wrong here, but that was my impression).

@item
Although @sc{dive} does not (transparently) allow blitting only a portion of
backbuffer to screen, there is still a solution.  The key is to call each time
@code{DiveSetupBlitter()} with same parameters as usual, but clipping first
all rectangles returned by @code{GpiQueryRegionRects()} against the rectangle
you want to update.  Look in @file{libDIVE.cpp}
(@code{diveWindow::SetupBlitter}) for more details.

@item
Although documentation states that @code{DiveSetupBlitter()} is a longplay
operation, I think if you should update only a small part of screen it is
still faster to use it (for example, @sc{csws} mostly needs to update only the
portion of screen around mouse cursor, @ref{CSWS}).  @code{DiveSetupBlitter()}
is not called multiple times if update region does not change, so if you
always call @code{Graphics2D::Print()} with a constant argument (or
@samp{NULL} for entire area), it won't be called more often than in the
``classic'' situation.

@item
There is an @emph{almost full-screen} @sc{dive} mode of operation available.
To activate/deactivate it you can press @key{ALT}-@key{HOME} (like in @sc{dos}
windows).  In this mode window is resized so that window borders and window
title will fall outside of physical screen, and @sc{dive} window occupies
entire screen.  The bad side is that you get not too high frame rates in this
mode (for example, on Matrox Mystique a window 320x200x256 rescaled to
1152x864x64K can be updated only about 15 times per second).

@item
The system menu on Crystal Space window is replaced by a more
application-specific menu.  There are some useful options there (also
available through hot-keys, for example @kbd{@key{CTRL}-@key{ALT}-1} rescales
window to 1:1 scale, @kbd{@key{CTRL}-@key{ALT}-2} to 2:1, and so on).  The
menu definition is contained in @file{libDIVE.rc}.  If you need some
additional entries, you can add them directly to resource file.
@end itemize

@emph{Note}: If you're running 16 @sc{bpp} or 32 @sc{bpp} on Matrox cards,
make sure you disabled the ``Enable EnDIVE in 16 @sc{bpp} and 32 @sc{bpp}''
checkbox in the Matrox settings notebook.  This is a real performance killer.
(@sc{fps} drops twice on my Matrox II AGP, for example.)

@node OS2 Input, OS2 Crashes, OS2 DIVE Features, OS2 Details
@subsubsection Mouse and Keyboard
@cindex @sc{os}/2 Mouse and Keyboard

I was too lazy to intercept system event queue, so code generates all Crystal
Space events from events that are passed to @sc{dive} window.  As a
consequence, there are some (minor) flaws:

@itemize @bullet
@item
If you press a mouse button inside Crystal Space window, then move the mouse
outside the window and release button, Crystal Space won't receive the
``mouse-up'' event, since @OSTWO{} passes mouse events to a window only if
mouse is over that window.  Theoretically this can be fixed by capturing mouse
when any mouse button is pressed and releasing mouse when all mouse buttons
will be released.  I didn't have time to do it, and anyway it is not so
important I think.

@item
If you press a key inside the window, then activate another window and release
it, the same happens as with mouse buttons.  Keyboard events are passed by
@OSTWO{} only to active windows.  To avoid this, the default @emph{focus
changed} handler in @samp{csSystemDriver} class calls @code{Keyboard->Reset()}
and @code{Mouse->Reset()} if focus goes away.  @code{Keyboard::Reset()} clears
all @emph{key pressed} flags and emmits corresponding @samp{csevKeyUp} events.
@code{Mouse::Reset()} clears all @emph{button down} flags and emmits
corresponding events too.
@end itemize

By default Crystal Space Windowing System will use builtin @OSTWO{} mouse
pointers whenever possible (there are three cursors that do not have their
counterparts in @OSTWO{} and will be emulated in software).  This behaviour
can be controlled by the @samp{SYS_MOUSE_CURSOR = @{@var{yes}|@var{no}@}}
parameter in configuration file.  If set to @samp{yes}, system mouse pointers
will be used when available; if set to @samp{no}, mouse pointers will be drawn
by Crystal Space as 2D sprites.  This is slower but more precise.
Theoretically @code{csGraphics2D::SetMousePointer()} can be implemented to
construct a @OSTWO{} pointer from @samp{native} Crystal Space textures, but I
was too lazy for this.

@node OS2 Crashes, , OS2 Input, OS2 Details
@subsubsection Mysterious Crashes
@cindex @sc{os}/2 Crashes

If you just compiled @file{walktest} or @file{MazeD} or some other executable
(or even @file{scfreg}), run it and get mysterious exits or crashes during
startup, it could be caused by the following problem.

I had a precompiled version of the @sc{jpeg} and @sc{png} dynamic libraries
that were compiled with @samp{-Zcrtdll}.  And compiled Crystal Space with
@samp{-Zsys}, that is without @sc{emx c} runtime @sc{dll}s.  For some reason
this combination doesn't work until C/C++ compilers and company are resident
in memory (if you're using @samp{set GCCLOAD}).  So you should either
recompile everything with @samp{-Zsys}, or recompile everything with
@samp{-Zcrtdll}, or do a @samp{emxload -q} before running such executables.

@unmacro OSTWO
