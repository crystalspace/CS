@c -*-texinfo-*-
@node Memory Debugger, , Makefile How-To, Internals
@section Crystal Space Memory Debugger
@cindex Memory Debugger

@noindent
@emph{Written by Andrew Zabolotny, @email{bit@@eltech.ru}.}

The goals of the Crystal Space memory debugger are listed below:

@itemize @bullet
@item
Help find memory leaks.  In a complex program such as Crystal Space it is
often difficult to find memory leaks analytically.  Most often you even won't
observe that a memory leak occurred, unless the leak is quite significant.

@item
Help find situations when a memory block is used after being freed.  This
doesn't happen too often, but if it happens, it is quite dangerous.

@item
Help find usage of uninitialized memory.

@item
Help find situations when programs writes outside the bounds of the allocated
memory block.

@item
Help gather memory usage statistics about the program.
@end itemize

@menu
* Memory Debugger Usage:: Usage
* Memory Debugger mapfile:: Map File Format
* Memory Debugger Internals:: How It Works
@end menu

@node Memory Debugger Usage, Memory Debugger mapfile, Memory Debugger, Memory Debugger
@subsection Usage

To enable the memory debugger you should first of all compile in ``debug''
mode.  It is possible to use it in ``optimize'' mode but you will get
hexadecimal addresses instead of @emph{file name}, @emph{function name}, and
@emph{line number} information.

Next, you don't need to recompile the engine from scratch, like you used to
do with the old memory debugger (that used @code{CHK()} macros). You just
work as usual and if you need the memory debugger, you recompile with the
@samp{MEMDBG} variable set to 1.  For example:

@example
make walk mode=debug MEMDBG=1
@end example

This will just compile @file{memdbg.cpp} and link all other object files and
libraries with this one.  Linking against this file automatically enables the
memory debugger.

Now you should create a map file for your executable.  A map file is a text
file that contains information about source files, functions and line numbers
of your programs.  The format of the map file is explained in the following
section.  @xref{Memory Debugger mapfile}.

The map file is created with the @file{CS/bin/memdbg.sh} script.  You do it
this way:

@example
bin/memdbg.sh ./walktest [@var{options}]
@end example

This will create a file called @file{memdbg.map}.  You also can provide some
options after giving the name of executable.  These options tell the memory
debugger what tasks to perform.  Here is a summary on each option.  @emph{Note
that character case is significant!}

@table @samp
@item a
@emph{Fill memory after allocation with garbage.}  This is highly recommended
as it is not too expensive but allows to detect cases when memory is used
without being initialized first.

@item f
@emph{Fill freed memory with garbage but don't actually free it.}
@strong{Warning:} This is quite expensive in terms of memory consumption.

@item d
@emph{Cause program to brak into debugger upon detection of serious errors.}
The debugger will break inside operator @samp{new} or @samp{delete} right
before exiting back to user program.  By stepping a few times you can detect
the place where error occurred.

@item v
@emph{Cause memory debugger to print an informational string each time
@samp{new} or @samp{delete} is called.}  It is recommended that you to
redirect @samp{stdout} when using this flag as output to console will
immensely slow down your program.

@item s
@emph{Emit a summary sheet at the end of program execution.}  The sheet will
list the summary number of memory allocations, deallocations, the peak memory
consumption, and a lot of other useful information.

@item l
@emph{Emit a list of unfreed memory blocks at the end of program.}  The list
will also contain the location where the corresponding memory block was
allocated.

@item b
@emph{Detect writes past the block boundaries.}  This is implemented by
allocating slightly bigger blocks than actually requested, and by filling
those inter-block spaces with some well-known value.  When block is freed, the
space between blocks is checked to verify that it still contains the same
well-known value.

@item L
@emph{Redirect (append) output from console to a log file called
@file{memdbg.log}.}
@end table

Default options are @samp{aslbL}.  To enable extensive checking use
@samp{aslbLf}.  To enable all options use @samp{aslbLfdv}.  Thus, to disable
everything except the log file and the summary, you type:

@example
bin/memdbg.sh ./walktest sL
@end example

After you created the map file, just run your program as usual.  If your
program doesn't have a separate @samp{stdout} stream (such as on @sc{dos},
@sc{os/2}, Windows, MacOS/9) it is recommended that you always use log file;
if you didn't you can still redirect the @samp{stdout} to a file using the
@samp{stdout} redirection, if it is possible (for intance, @samp{./walktest >
logfile}).

If you will want later to change debugging options, you can load the map file
into any text editor (that will handle such large files) and change the first
line (that starts with a capital @samp{O}).

If you did everything correctly, you should get similar references to
locations:

@example
+--------+----------+- Unfreed memory blocks -------------------
|  size  |  address |location where block was allocated
+--------+----------+-------------------------------------------
|     239|   0x89970|file /home/CS/memdbg/test.cpp:28, func main
@end example

If you get such text:

@example
+--------+----------+- Unfreed memory blocks--------------------
|  size  |  address |location where block was allocated
+--------+----------+-------------------------------------------
|     200|   0x32b70|unknown (0x10239)
|     239|   0x87f50|unknown (0x10189)
@end example

This means that the map file is either incorrect, or does not contain location
information about the above addresses.  However, this does not invalidate the
usefulness of the memory debugger, it just makes reading of the log file more
complex.  Usually each compiler system provides a way to find out the source
module and the line number that is closest to given address.  For @sc{gnu} set
of development tools this is done with the @file{addr2line} tool.  You also
can do it with @file{gdb}.

@node Memory Debugger mapfile, Memory Debugger Internals, Memory Debugger Usage, Memory Debugger
@subsection Map File Format

Map file has a very simple format.  Currently the map file is created by
piping output from the @file{nm} program through an @sc{awk} script, but you
can write other tools that create @file{.map} files.  That's why I'll describe
the format of map file in details.  Even more details you can gather from the
source code, as always.

The map file is a plain text file.  Lines that start with @samp{#} or @samp{;}
are ignored.  Otherwise each line starts with an letter that identifies which
type of information is presented on that line.  Here is a list of all
identificators, what they mean, and what information is expected on that line.

@table @code
@item O @var{string}
Memory Debugger [O]ptions. Example:

@example
O aslbL
@end example

@item S @var{hexnum} @var{string}
[S]ource module start.  The @var{hexnum} parameter defines the start address
of the object module in hexadecimal; the @var{string} is just the source file
name.  Example:

@example
S 10038 /home/andy/CS/memdbg/test.cpp
@end example

@item F @var{hexnum} @var{string}
[F]unction start.  The @var{hexnum} parameter defines the hexadecimal function
address; the @var{string} is the function name.  Example:

@example
F 10370 output(char const*,...)
@end example

@item L @var{hexnum} @var{decnum}
This denotes a [L]ine number.  The @var{hexnum} parameter is the hexadecimal
address of the line, the @var{decnum} is the line number (in decimal).
Example:

@example
L 10071 11
@end example

@item D @var{hexnum-a} @var{hexnum-b} A|F
This command is for advanced users only.  It is not written by
@file{memdbg.sh} script, and is inserted manually by you using an editor.  The
first hexadecimal number (@var{hexnum-a}) is the address of memory block, the
second (@var{hexnum-b}) is the address inside your executable.  The literal
flag @samp{A} or @samp{F} means to invoke a debug breakpoint either during
allocation of deallocation (freeing) of that block.  On Intel x86 architecture
this is the @samp{int 3} instruction.  This feature can be used to track very
specific bugs.  Example:

@example
D 32b70 10370 A
@end example
@end table

The addresses for the @samp{S}, @samp{F}, and @samp{L} keywords should be
sorted in increasing order; i.e.  the memory debugger supposes that all lines
are pre-sorted by increasing value of their address.  Otherwise you will get
very strange line references (or hexadecimal addresses like at the end of
previous section).

@node Memory Debugger Internals, , Memory Debugger mapfile, Memory Debugger
@subsection How It Works

Here are some technical details about the functioning of the memory debugger.
This can help you understand better how it works, and I think this can help
you use the debugger in a more productive fashion.

In each @samp{new} or @samp{delete} call, we check whenever we have been
initialized.  If not, we call the initialization function that parses the
@file{.map} file, sets the debugging options and so on.  When program exits
the memory debugger checks for unfreed memory block, displays statistics and
so on.  This is done by declaring a dummy static variable at the very end of
memory debugger module and the shutdown function being called from its
destructor.

The only trick used in memory debugger is used to get the address from where
@samp{new} and @samp{delete} have been called.  This is a processor-dependent
issue, alas we can't do it in a platform-independent fashion.  To support
doing this on different platforms we define a macro called
@code{GET_CALL_ADDRESS()}.  We pass the first argument of the procedure we're
invoking @code{GET_CALL_ADDRESS()} from and we get the address from were we
were called in a variable called @samp{addr}.

Here are details on how we're doing it on different platforms:

@table @emph
@item Intel x86
These processors use a stack for passing arguments, and the same stack is used
to push the return address.  Since all machines uses a top-to-bottom stack
(i.e.  stack increases in the direction of lower addresses), and also since
@sc{ansi c} standard requires that the addresses of function arguments
increase (that is, if you're defining a function such as @samp{void some(int
a, int b)} you can be absolutely sure that address of @samp{b} is higher than
address of @samp{a}.  It is a good guess to suppose that on most computers as
of today upon the invocation of the @samp{new} and @samp{delete} operators the
stack will look like this:

@example
+-----------------+ higher addresses
|       arg2      |        ^
+-----------------+        |
|       arg1      |        |
+-----------------+        |
|  return address |        |
+-----------------+ lower addresses
@end example

This means that if we take the address of first argument of the procedure and
go one machine word back, we'll get the address of the function's @dfn{return
address} word.  Now we peek it from there and we have the return address.
This is embedded into a macro that looks like this:

@example
#define GET_CALL_ADDRESS(firstarg) \
  address addr = ((address*)&firstarg) [-1];
@end example

@noindent
Where @samp{address} is a shortcut for type @samp{void*}.

@item An Almost Cross-Platform Solution
Fortunately for us, @sc{gcc} versions above 2.8.0 have a extremely useful
built-in function called @code{__builtin_return_address()}.  If we invoke it
with the argument zero, it returns just what we need; the address from where
our procedure was called.  Thus, an almost-cross-platform
@code{GET_CALL_ADDRESS()} is implemented this way:

@example
#if (__GNUC__ >= 2) && (__GNUC_MINOR__ >= 8)
#  define GET_CALL_ADDRESS(firstarg) \
     address addr = (address)__builtin_return_address(0);
#endif
@end example

Thus, if you can't get @file{memdbg.sh} to work, you should find a newer
@sc{gcc}; this should always help.
@end table
