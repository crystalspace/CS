@c -*-texinfo-*-
@node Sprite Actions, The Sprite Action Interface, Introduction, Animation
@subsection Sprite Actions

@emph{Written by Michael Voase,
@email{mvoase@@midcoast.com.au}.}

A sprite action is a series of frames which contains the position of each
vertex in a sprite for a particular time. This means for each frame, a
complete duplicate of the vertex list must be loaded into the sprite for
each frame. The positions of the vertices of course will vary, however, the
number of vertices in each frame must be equal. We will cover why later.

@subsubheading Creating a Sprite in a Map File

A sprite in a map file consists of two declaration. The first is the
declaration for its @dfn{factory} the second is a declaration of its 
@dfn{instance} in a given sector. The factory declaration is what we are
mostly interested in at the moment.

Now if you recall from Mesh Object Concepts (@pxref{MeshObject Concepts}), the
factory acts as a database of all the vertices, triangles and texels used
to define a mesh object. The primary purpose of this is to have a single
database for each mesh object. So this is where we will be defining our
sprite with its multiple actions.

The declaration starts with the @samp{meshfact} token, and looks something
like this:

@example
<meshfact name="fact">
  <plugin>crystalspace.mesh.loader.factory.sprite.3d</plugin>
  <params>
    <material>white</material>
    <frame name="first">
      <v x="0" y="0" z="0" u="0" v="0"/>
      <v x="0" y="1" z="0" u="0" v="0"/>
      <v x="1" y="0" z="0" u="0" v="0"/>
      <v x="0" y="0" z="1" u="0" v="0"/>
    </frame>
    <frame name="second">
      <v x="0" y="0" z="0" u="0" v="0"/>
      <v x="0" y="1.2" z="0" u="0" v="0"/>
      <v x="1.2" y="0" z="0" u="0" v="0"/>
      <v x="0" y="0" z="1.2" u="0" v="0"/>
    </frame>
    <frame name="third">
      <v x="0" y="0" z="0" u="0" v="0"/>
      <v x="0" y="1.4" z="0" u="0" v="0"/>
      <v x="1.4" y="0" z="0" u="0" v="0"/>
      <v x="0" y="0" z="1.4" u="0" v="0"/>
    </frame>
    <frame name="fourth">
      <v x="0" y="0" z="0" u="0" v="0"/>
      <v x="0" y="1.2" z="0" u="0" v="0"/>
      <v x="1.2" y="0" z="0" u="0" v="0"/>
      <v x="0" y="0" z="1.2" u="0" v="0"/>
    </frame>
    
    <t t1="0" t2="1" t3="2"/>
    <t t1="0" t2="3" t3="1"/>
    <t t1="0" t2="2" t3="3"/>
    <t t1="1" t2="3" t3="2"/>
    
    <action name="default">
      <f name="first" delay="200"/>
      <f name="second" delay="200"/>
      <f name="third" delay="200"/>
      <f name="fourth" delay="200"/>
    </action>
  </params>
</meshfact>
@end example

This example defines a triangular pyramid which grow larger and smaller.
To put this sprite into action, you also need to declare an instance of
the sprite in a sector. In your map file (somewhere inside a @samp{sector}
declaration), place the following mesh object declaration.

@example
<meshobj name="test1">
  <plugin>crystalspace.mesh.loader.sprite.3d</plugin>
  <params>
    <factory>fact</factory>
    <action>default</action>
    <tween />
  </params>
  <move>
    <v x="0" y="0" z="5.0" />
  </move>
  <priority>object</priority>
  <zuse />
</meshobj>
@end example

After zipping the map file up with your sprite you should see and active
sprite five units in front of you.

@subsubheading Meaning of the Sprite

Okay, we have an example of a an animation. As you can see from the example,
the sprite @emph{factory} declaration, the sprite consists of four frames
each enclosed in the @samp{frame} keyword. Each frame defines the vertices
of the pyramid in each frame. The @samp{v} token stands for @emph{vertex}.
You will also note that each frame contains a name. This is important as the
name is used to reference the frame. This applies to both map files and
the sprite 3D interface.

After the frames have been defined, a list of triangles is then declared.
Note that the @samp{t} tokens are declared after the frames. Trying
to define the triangles before the frames will result in an error and will
be flagged as such. Each @samp{t} declaration contains three indices
to the defined frame vertices. The index starts at zero and has a maximum
value equal the number of vertices minus one. During the course of animation
the triangle lists are applied to the corresponding frame and are then
sent to the graphics renderer. This is one reason why each frame must
contain the same number of vertices. Lastly, at the end of the mesh factory
declaration, there is an @samp{action} declared. 

@subsubheading Action Declaration

The declaration starts with the @samp{action} token and is then followed by
the name of the action. Setting the name is important as this is how you
will reference the action both in the map file and in the sprite interface.
Its also a good idea @emph{not} to use the same name twice, as you will prevent
the second action from being accessed. You can use the same name for an action
and a frame, as they are stored in different places. In general though,
never use the same name for two items of the same type, whether it be a mesh
object, a frame, or whatever.

After the name of the action, we enter into the body of the action where the
frame @dfn{sequences} are defined. Each frame of the sequence starts with
the @samp{F} token (standing for frame) and contains the name of the frame
and the duration that it is valid for. The frame name must be one from the 
previous list of frames and the duration is in milliseconds. The duration 
represents how long the frame will be shown for. This sprite contains only
one action. It can contain many actions. However, in all cases there must be
at least one action (usually called @emph{default}) defined for the sprite.

Lastly to implement this action, the @samp{action} keyword is used in the
mesh object declaration to tell the engine which action to use on this sprite
instance. If no action is defined in the mesh object then the engine will
use the first action defined in the factory regardless of its name.

@subsubheading Tweening and Actions.

You may have noticed that the animation looks somewhat jumpy when viewed.
This is due to the tweening flag on the sprite @dfn{instance} being set
to false. To enable tweening, set the tweening flag to true (it is normally
enabled). Tweening is a method of producing a smoother animation by
interpolating the position of the vertices between frame based on a ratio
of the time into the frame and the duration of the frame. Enabling
tweening in an animation involves an additional overhead in calculating
the interpolated vertices, however, produces a more satisfactory result.
This is also the second reason why each frame must have the same number
of vertices.
