@c -*-texinfo-*-
@node Release Notes 100, Release Notes 98, Release Notes, Release Notes
@appendixsec Release Notes from 0.98 to 1.00
@cindex Release Notes

This section documents the major changes between versions 0.98 and 1.00 of
Crystal Space.

@subheading @code{csArray<>} Index and Size Type Change

@code{csArray<>} has been changed to use @samp{size_t} instead of
@samp{int} for array sizes and indices.  Probably, the most significant
semantic difference of this change is that @samp{size_t} is usually
@emph{unsigned} as opposed to @samp{int} which is @emph{signed}.

@strong{Read this paragraph carefully.} In actual code, this change may result
in nothing more than simple-looking compiler warnings. However, it may have
caused @emph{semantics} to change subtly.

This has the greatest impact in the following areas discussed below.

@subsubheading Iterating Over @code{csArray<>} Contents

For this purpose, usually, @samp{int} typed variables were used for keeping
track of the index of the current item of an array iteration.  Fixing forward
iteration over a @code{csArray<>} to instead use @samp{size_t} is simple:

@example
csArray<@dots{}> a;
for (int i = 0, n = a.Length(); i < n; i++)
@{
  @dots{}
@}
@end example

@noindent
Is changed to:

@example
@dots{}
for (size_t i = 0, n = a.Length(); i < n; i++)
@dots{}
@end example

Backward iteration is a bit more problematic. As mentioned before,
@samp{size_t} typically is unsigned, so you do not have negative values. This
can be a problem in constructs like:

@example
csArray<@dots{}> a;
for (int i = a.Length() - 1; i >= 0; i--)
@{
  @dots{}
@}
@end example

If the @samp{int} is changed simply to a @samp{size_t}, this 
@code{for}-loop misbehaves unexpectedly. When @samp{i} becomes 0, the body 
of the loop is executed correctly. However, decrementing @samp{i} will 
@strong{not} cause @samp{i} to have a negative value---after all, @samp{size_t}
is unsigned. Instead, decrementing will make @samp{i} wrap around from 0 to
0xffffffff (on 32-bit machines). Clearly, this is greater
than 0, effectively causing an infinite loop. The same thing also happens when
@samp{a} has no items (i.e. @samp{a.Length() == 0}). Here the
-1 in the initialization of @samp{i} causes wrap-around.

Possible solutions include:

@itemize @bullet
@item
Use an @code{int}-typed counter variable and cast the array length to
@samp{int}.  This is not entirely elegant, but it does the job in most cases.

@item
Re-write the loop to deal properly with the unsigned nature of @samp{size_t}:

@example
csArray<@dots{}> a;
for (size_t i = a.Length(); i-- > 0;)
@{
  @dots{}
@}
@end example

This code does the same as the @samp{int} version above, iterating from 
@samp{a.Length() - 1} to 0, inclusively. It also correctly works
in the case @samp{a.Length() == 0}. The ``trick'' is to place the 
modification of @samp{i} as a post-decrement in the loop condition. This 
way, as soon as @samp{i} becomes 0, the loop is terminated. The 
post-decrement ensures that @samp{i} has the expected value in the loop body.

@end itemize

@subsubheading Searching

Functions like @code{csArray<>::FindSortedKey()} and @code{csArray<>::Find()}
used to return -1 to signify that an item was not found.  This is still the
case, but with a twist.  Now, @samp{(size_t)-1} is returned.  For convenience,
a constant, @samp{csArrayItemNotFound}, has been added, which has this exact
value.  It can be used in comparisons to make it clear what is actually being
checked.

Apropros comparisons: Recall that @samp{size_t} is @emph{unsigned}, so checking
whether an index returned by @samp{FindSortedKey()} or @samp{Find()} is 
actually a valid index by testing with @samp{>= 0} no longer works since
@samp{(size_t)-1} is always @code{>= 0}. Replace such checks with tests of
equality against @samp{csArrayItemNotFound}:

@example
csArray<@dots{}> a;
int index = a.Find (@dots{});
if (index >= 0)
@{
  /* Item found */
  @dots{}
@}
else
@{
  /* Item not found */
  @dots{}
@}
@end example

Must be replaced with:

@example
csArray<@dots{}> a;
size_t index = a.Find (@dots{});
if (index != csArrayItemNotFound)
@{
  /* Item found */
  @dots{}
@}
else
@{
  /* Item not found */
  @dots{}
@}
@end example

@subheading Texture and Material Preparation

Texture and material preparation is now fully automatic. It is no longer
necessary to @dfn{prepare} a texture or a material before you can use it. It is
sufficient simply to register the texture or material. This means that the
following functions have been removed (and you can just remove invocations of
them from your applications if you used them):

@itemize @bullet
@item
@code{iMaterialHandle::Prepare()}
@item
@code{iTextureHandle::Prepare()}
@item
@code{iTextureManager::PrepareMaterials()}
@item
@code{iTextureManager::PrepareTextures()}
@end itemize

@subheading Input Definitions

The file @file{csutil/inpnames.h} has been renamed to
@file{inputdef.h}, and the following functions have been removed:

@itemize @bullet
@item
@code{csTypeOfInputDef()}
@item
@code{csParseKeyDef()}
@item
@code{csGetKeyDesc()}
@item
@code{csParseMouseDef()}
@item
@code{csGetMouseDesc()}
@item
@code{csParseJoystickDef()}
@item
@code{csGetJoystickDesc()}
@end itemize

These functions allowed you to convert a string such as @kbd{@key{Ctrl}+A},
@samp{JoystickX} or @samp{Alt+Mouse1} into values describing input events
and vice versa.

The way to do this is now, however, is to use @samp{csInputDefinition}, which
resides in @file{csutil/inputdef.h}. The preferred way to convert a string to a
definition is to construct a @samp{csInputDefinition} from a
@samp{char const*}; and the preferred way to convert a definition back to a
string (perhaps constructed some other way) is via
@code{csInputDefinition::ToString()}.

There are also static helper methods in @samp{csInputDefinition} which accept
arguments in a similar way to the old functions. These are convenience methods
which perform the work of instantiating the object for you:

@itemize @bullet
@item
@code{csInputDefinition::ParseKey()}
@item
@code{csInputDefinition::GetKeyString()}
@item
@code{csInputDefinition::ParseOther()}
@item
@code{csInputDefinition::GetOtherString()}
@end itemize

@subheading Pollution Reduction

In order to avoid polluting the top-level system include directory, the Crystal
Space header tree is now installed (via @samp{make install} or
@samp{jam install}) in a subdirectory named @file{crystalspace}, rather than
being installed directly in the top-level system directory. For example,
assuming the default installation location, the Crystal Space headers are now
installed in @file{/usr/local/include/crystalspace}. Previously, they would
have been deposited directly into @file{/usr/local/include}. The
@samp{cs-config} utility script properly returns the new header location in
response to the @samp{--includedir}, @samp{--cflags}, and @samp{--cxxflags}
options, so this relocation should be mostly transparent to external projects.

The following global header files have been renamed in order to avoid possible
conflict with headers installed by other packages.

@itemize @bullet
@item
@code{platform.h} @result{} @code{csplatform.h}
@item
@code{qint.h} @result{} @code{csqint.h}
@item
@code{qsqrt.h} @result{} @code{csqsqrt.h}
@item
@code{volatile.h} @result{} @code{csconfig.h}
@end itemize

The following symbols have been renamed in order to avoid pollution of the
global namespace.

@itemize @bullet
@item
@code{big_endian_float()} @result{} @code{csBigEndianFloat()}
@item
@code{big_endian_long()} @result{} @code{csBigEndianLong()}
@item
@code{big_endian_longlong()} @result{} @code{csBigEndianLongLong()}
@item
@code{big_endian_short()} @result{} @code{csBigEndianShort()}
@item
@code{COMP_BC} @result{} @code{CS_COMPILER_BCC}
@item
@code{COMP_GCC} @result{} @code{CS_COMPILER_GCC}
@item
@code{COMP_VC} @result{} @code{CS_COMPILER_MSVC}
@item
@code{convert_endian()} @result{} @code{csConvertEndian()}
@item
@code{CS_PROCSIZE} @result{} @code{CS_PROCESSOR_SIZE}
@item
@code{DO_MMX} @result{} @code{CS_USE_MMX}
@item
@code{DO_NASM} @result{} @code{CS_USE_NASM}
@item
@code{double2longlong()} @result{} @code{csDoubleToLongLong()}
@item
@code{float2long()} @result{} @code{csFloatToLong()}
@item
@code{float2short()} @result{} @code{csFloatToShort()}
@item
@code{get_le_float16()} @result{} @code{csGetLittleEndianFloat16()}
@item
@code{get_le_float32()} @result{} @code{csGetLittleEndianFloat32()}
@item
@code{get_le_long()} @result{} @code{csGetLittleEndianLong()}
@item
@code{get_le_short()} @result{} @code{csGetLittleEndianShort()}
@item
@code{little_endian_float()} @result{} @code{csLittleEndianFloat()}
@item
@code{little_endian_long()} @result{} @code{csLittleEndianLong()}
@item
@code{little_endian_longlong()} @result{} @code{csLittleEndianLongLong()}
@item
@code{little_endian_short()} @result{} @code{csLittleEndianShort()}
@item
@code{long2float()} @result{} @code{csLongToFloat()}
@item
@code{longlong2double()} @result{} @code{csLongLongToDouble()}
@item
@code{MemoryMapFile()} @result{} @code{csMemoryMapFile()}
@item
@code{MemoryMapWindow()} @result{} @code{csMemoryMapWindow()}
@item
@code{MKDIR()} @result{} @code{CS_MKDIR()}
@item
@code{mmioInfo} @result{} @code{csMemMapInfo}
@item
@code{__NEED_GENERIC_ISDIR} @result{} @code{CS_USE_CUSTOM_ISDIR}
@item
@code{__NEED_OPENDIR_PROTOTYPE} @result{} @code{CS_WIN32_USE_CUSTOM_OPENDIR}
@item
@code{OS_DOS} @result{} @code{CS_PLATFORM_DOS}
@item
@code{OS_MACOSX} @result{} @code{CS_PLATFORM_MACOSX}
@item
@code{OS_UNIX} @result{} @code{CS_PLATFORM_UNIX}
@item
@code{OS_WIN32} @result{} @code{CS_PLATFORM_WIN32}
@item
@code{PATH_DELIMITER} @result{} @code{CS_PATH_DELIMITER}
@item
@code{PATH_SEPARATOR} @result{} @code{CS_PATH_SEPARATOR}
@item
@code{PROC_FOO} @result{} @code{CS_PROCESSOR_FOO} (where @samp{FOO} is
@samp{X86}, @samp{M68K}, etc.)
@item
@code{QInt()} @result{} @code{csQint()}
@item
@code{QInt16()} @result{} @code{csQint16()}
@item
@code{QInt24()} @result{} @code{csQint24()}
@item
@code{QInt8()} @result{} @code{csQint8()}
@item
@code{qisqrt()} @result{} @code{csQisqrt()}
@item
@code{QRound()} @result{} @code{csQround()}
@item
@code{qsqrt()} @result{} @code{csQsqrt()}
@item
@code{set_le_float16()} @result{} @code{csSetLittleEndianFloat16()}
@item
@code{set_le_float32()} @result{} @code{csSetLittleEndianFloat32()}
@item
@code{set_le_long()} @result{} @code{csSetLittleEndianLong()}
@item
@code{set_le_short()} @result{} @code{csSetLittleEndianShort()}
@item
@code{short2float()} @result{} @code{csShortToFloat()}
@item
@code{TEMP_DIR} @result{} @code{CS_TEMP_DIR}
@item
@code{TEMP_FILE} @result{} @code{CS_TEMP_FILE}
@item
@code{UnMemoryMapFile()} @result{} @code{csUnMemoryMapFile()}
@item
@code{WIN32_VOLATILE} @result{} @code{CS_WIN32_CSCONFIG}
@end itemize

@subheading @file{cssysdef.h} Changes

The @samp{CS_SYSDEF_PROVIDE_FACILITY} macros, which clients would
@code{#define} before including @file{cssysdef.h} in order to alter the
behavior of @file{cssysdef.h}, have been removed. Retirement of these macros
eliminates the polymorphic behavior of @file{cssysdef.h}, thus helping to pave
the way toward eventually pre-compiling Crystal Space's headers in order to
reduce overall compilation time.  In addition to removing these macros from
your code, the following table explains what else (if anything) needs to be
done to account for the removal.

@table @code
@item CS_SYSDEF_PROVIDE_ACCESS
No additional changes.
@item CS_SYSDEF_PROVIDE_ALLOCA
Use the @samp{CS_ALLOC_STACK_ARRAY()} macro, rather than @code{alloca()}.
@item CS_SYSDEF_PROVIDE_CASE
No additional changes.
@item CS_SYSDEF_PROVIDE_DIR
No additional changes.
@item CS_SYSDEF_PROVIDE_EXPAND_PATH
No additional changes.
@item CS_SYSDEF_PROVIDE_GETCWD
No additional changes.
@item CS_SYSDEF_PROVIDE_GETOPT
Include @file{csutil/getopt.h}.
@item CS_SYSDEF_PROVIDE_MKDIR
Use the @samp{CS_MKDIR(path)} macro to create the directory, rather than the
obsolete @samp{MKDIR()} macro.
@item CS_SYSDEF_PROVIDE_PATH
No additional changes.
@item CS_SYSDEF_PROVIDE_SELECT
No additional changes.
@item CS_SYSDEF_PROVIDE_SOCKETS
Include @file{csutil/sockets.h}.
@item CS_SYSDEF_PROVIDE_SOFTWARE2D
No additional changes.
@item CS_SYSDEF_PROVIDE_TEMP
Use the @samp{CS_TEMP_DIR} and @samp{CS_TEMP_FILE} macros, rather than the
obsolete @samp{TEMP_DIR} and @samp{TEMP_FILE} macros.
@item CS_SYSDEF_PROVIDE_UNLINK
No additional changes.
@item CS_SYSDEF_VFS_PROVIDE_CHECK_VAR
No additional changes.
@end table

The age-old restriction that @file{cssysdef.h} could be included only by source
files (@file{.cpp}) has been lifted. This restriction was an unfortunate
side-effect of the polymorphic behavior of @file{cssysdef.h} in the presence
of various @samp{CS_SYSDEF_PROVIDE_FACILITY} macros. It is now safe, even
recommended, to include @file{cssysdef.h} in header files (@file{.h}). Doing so
helps to make header files more self-contained, thus reducing the burden of
clients of those headers.

@subheading Convenience Libraries

Crystal Space now publishes several convenience libraries which eliminate much
of the drudgery associated with implementing @sc{scf} interfaces in certain
types of common plugin modules. For example, the @samp{csGraphics2D} class in
the new @file{csplugincommon} library implements the @samp{iGraphics2D}
interface and provides much of the functionality common to most canvases.
Likewise, the @samp{csGraphics3D} class implements the @samp{iGraphics3D}
interface and provides much functionality common to renderers. You are not
required to utilize these implementations when authoring your own plugins, but
they are available for your convenience.

The new convenience libraries are:

@table @code
@item csplugincommon
Canvas, image loader, particle system, renderer, shader, sound loader,
and sound renderer support.
@item csplugincommon_dx
DirectX support.
@item csplugincommon_osx
MacOS/X canvas support.
@item csplugincommon_ogl
OpenGL support.
@item csplugincommon_w32
Windows support.
@end table

For a complete list of available convenience classes, consult the header files
in the subdirectories of @file{CS/include/csplugincommon}.

@subheading Convenience Headers

For convenience, several top-level @dfn{master header} files have been added to
the project. These should simplify client usage by allowing users to choose the
level of granularity which suits them best.  The list of new header files
follows.

@table @code
@item crystalspace.h
Nearly all public headers in entire Crystal Space @sc{sdk}.
@item csgeom.h
Content of @file{CS/include/csgeom}.
@item csgfx.h
Content of @file{CS/include/csgfx}.
@item csplugincommon.h
Content of @file{CS/include/csplugincommon}.
@item cstool.h
Content of @file{CS/include/cstool}.
@item csutil.h
Content of @file{CS/include/csutil}.
@item csws.h
Content of @file{CS/include/csws}.
@item iaws.h
Content of @file{CS/include/iaws}.
@item iengine.h
Content of @file{CS/include/iengine}.
@item igeom.h
Content of @file{CS/include/igeom}.
@item igraphic.h
Content of @file{CS/include/igraphic}.
@item imap.h
Content of @file{CS/include/imap}.
@item imesh.h
Content of @file{CS/include/imesh}.
@item inetwork.h
Content of @file{CS/include/inetwork}.
@item isound.h
Content of @file{CS/include/isound}.
@item itexture.h
Content of @file{CS/include/itexture}.
@item iutil.h
Content of @file{CS/include/iutil}.
@item ivaria.h
Content of @file{CS/include/ivaria}.
@item ivideo.h
Content of @file{CS/include/ivideo}.
@end table

Users new to the @sc{sdk} will probably want to include @file{crystalspace.h}
since it is simplest; whereas more advanced users may want to include
@file{csutil.h}, @file{cstool.h}, etc.; and power users can continue to include
only the individual headers required by a particular piece of code.

As a corollary, the old @file{CS/include/css.h} header, which included many,
though not all Crystal Space header files, has been removed. If you require
this type functionality from a header, then include the new
@file{crystalspace.h} instead.

Be aware that there is a very small set of public headers not included in any
of the master headers. These are omitted from the master headers because they
reference external resources which might not be known or available to all
clients of the master headers. Clients requiring these special-case headers
will need to include them manually, on an as-needed basis, and arrange that the
build system has sufficient knowledge about the external resources to satisfy
the dependencies at build time.  The list of headers which are excluded from
the master headers follows.

@table @code
@item csplugincommon/directx/*.h
DirectX-specific.
@item csplugincommon/macosx/*.h
MacOS/X-specific.
@item csplugincommon/opengl/*.h
OpenGL-specific.
@item csplugincommon/win32/*.h
Windows-specific.
@item csutil/archive.h
Requires zlib indirectly via @file{csutil/zip.h}.
@item csutil/zip.h
Requires zlib; @uref{http://www.gzip.org/zlib/}
@item inetwork/vosapi.h
Requires @sc{vos}; @uref{http://www.interreality.org/}
@item ivaria/ode.h
Requires @sc{ode}; @uref{http://www.ode.org/}
@item ivideo/wxwin.h
Requires wxWidgets; @uref{http://www.wxwidgets.org/}
@end table

As an example, if you need access to the @samp{iWxWindow} interface, then you
must include @file{ivideo/wxwin.h} manually; it will not be included as part of
@file{crystalspace.h} or @file{ivideo.h}. Furthermore, you will need
to let the build system know where it can find the wxWidgets resources (headers
and libraries). Typically, this is done by adding a wxWidgets check to your
project's @file{configure} script; emitting the results of the check to your
@file{Jamconfig} file with the @code{CS_EMIT_BUILD_RESULT()} Autoconf macro;
and finally utilizing the result of that check in your project's @file{Jamfile}
by invoking the Jam rule @samp{ExternalLibs}. For @sc{msvc} project files, the
location of the wxWidgets resources will have to be added as @dfn{additional
include directories} and @dfn{additional library directories}, in the project
settings or globally, to ensure that @sc{msvc} will be able to find them.

@subheading Procedural Texture Relocation
 
Implementations of the standard procedural textures (dots, fire, plasma, etc.)
now reside directly in the @file{stdpt} plugin
(@file{CS/plugins/proctex/standard}), rather than in the @file{cstool}
library. Consequently, the following previously public headers are no longer
available:
 
@itemize @bullet
@item
@code{cstool/prdots.h}
@item
@code{cstool/prfire.h}
@item
@code{cstool/prplasma.h}
@item
@code{cstool/prsky.h}
@item
@code{cstool/prwater.h}
@end itemize
 
Likewise, procedural textures can no longer be allocated directly (for
instance, via @samp{new csProcFire}).  Instead, you must now use the plugin
system to create such textures. For example:
 
@example
csRef<iPluginManager> plugin_mgr(
  CS_QUERY_REGISTRY(object_reg, iPluginManager));
csRef<iTextureType> type(CS_QUERY_PLUGIN_CLASS (plugin_mgr,
  "crystalspace.texture.type.fire", iTextureType));
if (!type)
@{
  type = CS_LOAD_PLUGIN(plugin_mgr,
    "crystalspace.texture.type.fire", iTextureType);
@}
csRef<iTextureFactory> fireFact = type->NewFactory();
csRef<iTextureWrapper> tex = fireFact->Generate();
csRef<iFireTexture> fire = SCF_QUERY_INTERFACE(tex, iFireTexture);
@end example
 
Various procedural textures may or may not implement their own custom @sc{scf}
interfaces beyond the normal interfaces implemented by all procedural
textures. In the example above, the ``fire'' texture implements the specialized
@samp{iFireTexture}.

@subheading Joystick Corrections

The implementation of @samp{iJoystickDriver} has been fixed to treat joystick
numbers consistently. Previously, on account of buggy implementation, some
parts of the driver considered joystick numbers 0-based, while other parts
considered them 1-based.  It now uniformly treats joystick numbers as
1-based. This is consistent with button numbers for joysticks and mice, which
are also 1-based.

@subheading @code{iGraphics2D} Alpha Color Support

@samp{iGraphics2D} now supports an alpha channel. @code{iGraphics2D::FindRGB()}
accepts an optional alpha value (0 being completely transparent, and
255 being fully opaque) which defaults to 255. All canvases will then blend 
the pixels appropriately if the color depth is 15 bpp or higher. Furthermore, 
as @code{iGraphics2D::Write()} also handles alpha in both foreground and 
background colors, it is recommended for transparent backgrounds, instead 
of using @samp{-1} as the color value, to obtain a color value from 
@code{FindRGB()} that has the same R, G, B components as the foreground color, 
but an alpha component of 0.

@subheading @file{csutil/garray.h} Deprecated

The @file{csutil/garray.h} file, containing the class 
@code{csDirtyAccessArray<>}, has been deprecated in favor of the more sensible
file name @file{csutil/dirtyaccessarray.h}. No functional changes have been
made to the class.

@subheading @code{csList<>::Iterator} Normalization

The behavior of @code{csList<>::Iterator} has been normalized so that it
functions identically to all other iterators in Crystal Space.  In the past, a
newly created @code{csList<>::Iterator} already pointed at the first element in
the container.  This differed from all other iterator implementations, in which
the first element, like all other elements, is accessed by an invocation of
@code{Next()}.

Old code which accessed the elements of a @code{csList<>::Iterator} required a
non-standard idiom, such as:

@example
csList<sometype> list = @dots{};
csList<sometype>::Iterator it(list);
if (it.HasCurrent())
@{
  do_something(*it);         // First value.
  while (it.HasNext())
  @{
    do_something(it.Next()); // Remaining values.
  @}
@}
@end example

@noindent
Or, the slightly less complicated, though still somewhat convoluted:

@example
csList<sometype>::Iterator it(list);
while (it.HasCurrent())
@{
  do_something(*it);
  it.Next();
@}
@end example

Following normalization, @code{csList<>::Iterator} now works like all other
iterators throughout the toolkit.  In particular, for forward iteration, all
elements can be accessed via the standard @code{HasNext()} / @code{Next()}
idiom:

@example
csList<sometype>::Iterator it(list);
while (it.HasNext())
@{
  do_something(it.Next());
@}
@end example

@noindent
Likewise, for backward iteration, the @code{HasPrevious()} / @code{Previous()}
idiom works in the obvious and expected inverse fashion.

Finally, @code{csList<>::Iterator::Next()} and @code{Previous()} now return
references to contained elements, rather than pointers.  This makes the
interface of @code{csList<>::Iterator} internally consistent, as well as
consistent with other iterators throughout the toolkit, in which these methods
return references.

@subheading @code{iDocument} Changes

The @code{iDocument::Parse()} method now accepts an optional argument
indicating whether or not extraneous whitespace in @samp{CS_NODE_TEXT} nodes
should be condensed.  Most implementations of @samp{iDocument} will attempt to
respect this option if possible.  For implementations where it does not make
sense, the option will be ignored.

Previously, @sc{xml} implementations of @samp{iDocument} condensed whitespace
in @samp{CS_NODE_TEXT} nodes at @code{Parse()} time.  This is no longer the
case.  Whitespace is now preserved by default.  If the new behavior is
unsuitable for your case, use the new argument to @code{iDocument::Parse()} to
indicate that whitespace should be condensed.  This change was made in order to
conform to the latest @sc{xml} specification which states that @sc{xml}
scanners must preserve whitespace by default.  Consult the following documents
for more information regarding this issue.

@noindent
@uref{http://www.w3.org/TR/REC-xml/#sec-white-space}@*
@uref{http://www.xml.com/axml/notes/AllWSAlways.html}

@subheading Naming Normalization

The following @sc{scf} class names have been normalized in order to be
consistent with the names of all other available ``null'' plugins:

@itemize @bullet
@item
@code{crystalspace.mesh.object.nullmesh} @result{}
@code{crystalspace.mesh.object.null}
@item
@code{crystalspace.graphics2d.null2d} @result{}
@code{crystalspace.graphics2d.null}
@end itemize

For consistency with like-named methods in other @sc{scf} interfaces, the
following @samp{iImage} methods have been renamed:

@itemize @bullet
@item
@code{GetKeycolor()} @result{} @code{GetKeyColor()}
@item
@code{HasKeycolor()} @result{} @code{HasKeyColor()}
@end itemize

For consistency with related methods (such as @code{HasPrevious()}) in the
@code{csList<>} template, the following methods have been renamed:

@itemize @bullet
@item
@code{FetchPrev()} @result{} @code{FetchPrevious()}
@item
@code{HasPrev()} @result{} @code{HasPrevious()}
@end itemize

For clarification, the following @code{csHash<>} methods have been renamed:

@itemize @bullet
@item
@code{PutFirst()} @result{} @code{PutUnique()}
@end itemize

@subheading Default @code{csHash<>} (and @code{csHashReversible<>}) Table Size

The default hash table size and grow rate has been reduced from 257 and 64 to
23 and 5, respectively, to have hashes use less memory.  If a hash is expected
to contain a large quantity of elements, those two parameters can be tweaked
upon construction of a @code{csHash<>} or @code{csHashReversible<>}.  Consult
the Public @sc{api} Documentation of @code{csHash<>} for more information.

@subheading @code{iTextureManager::FreeImages()} Removal

@code{iTextureManager::FreeImages()} has been removed.  It was used to release
the @samp{iImage} objects associated with textures with the purpose of freeing
up memory.  This happens automatically now; the images associated with a
texture are released by the renderer as soon as the image data is converted
into the internal texture format (that is, uploaded to the graphics hardware).

@subheading Java Bindings
@cindex Java

The Java bindings for Crystal Space have been fully integrated into the project
and are now well-supported. It is now possible to write Crystal Space program
entirely in Java. @xref{Java Bindings}.

The Crystal Space Java classes now reside in a package named
@samp{org.crystalspace3d} in order to reflect Crystal Space's new official
domain name ``crystalspace3d.org''. This replaces the older package name
@samp{com.crystalspace}, which itself replaced the much older name
@samp{net.sourceforge.crystal}.

@subheading @sc{vfs} Changes
@cindex @sc{vfs} Configuration File
@cindex @file{vfs.cfg}, @sc{vfs} Configuration File

At initialization time, @sc{vfs} now merges all @file{vfs.cfg} files located
during its start-up scan.  Previously, @sc{vfs} stopped scanning at the first
discovered @file{vfs.cfg}, and loaded only that file.  During the start-up
scan, it searches for a file named @file{vfs.cfg} in the application resource
directory (@code{csGetResourceDir()}), then in the directory containing the
application (@code{csGetAppDir()}), and finally in the Crystal Space
installation directory (@code{csGetConfigPath()}).  The full set of directories
mounted by @sc{vfs} following the initial configuration file scan is the union
of the entries in all of the discovered @file{vfs.cfg} files.  If there are
conflicting entries, then mounts and variable assignments specified in
configuration files discovered earlier in the scan take precedence over those
discovered later.

@subheading @code{iEvent} Changes

The @code{iEvent::Find()} method was renamed to @code{Retrieve()} and exhibits
different return value semantics. Rather than returning a mere boolean result,
it now returns one of the @samp{csEventError} enumeration constants.  Of
particular note, in the case of success, @code{csEventErrNone} is returned,
which has a value of 0. This success value could be misinterpreted as ``false''
by the unwary when fixing code to deal with this semantic change. Conditionals
which test if retrieval of an attribute succeeded must be changed to take this
new semantic into account. For instance, code such as the following:

@example
iEvent* ev = @dots{};
if (ev->Find(@dots{}))
@{
  @dots{}
@}
@end example

@noindent
must be changed to perform an explicit test on the return value of
@code{Retrieve()}, rather than relying upon default boolean semantics:

@example
if (ev->Retrieve(@dots{}) == csEventErrNone)
@{
  @dots{}
@}
@end example

@subheading Old Renderer Architecture Removed

The old rendering architecture along with the old renderer plugins have been
removed. Additionally, a few plugins, applications, classes, and methods have
been deprecated because they are not applicable to the new rendering
architecture. The results of the old renderer removal are summarized below.

@subsubheading Removed plugins

The following plugin modules have been removed:

@itemize @bullet
@item
@code{terrfunc} (@code{crystalspace.mesh.object.terrfunc})
@item
Old @code{gl3d} (@file{plugins/video/renderer/opengl})
@item
Old @code{soft3d} (@file{plugins/video/renderer/software})
@item
Old @code{null3d} (@file{plugins/video/renderer/null})
@end itemize

@subsubheading Removed Application

The @samp{perftest} application has been removed, since it is no longer has any
purpose.  For the future the @samp{csbench} application should be extended to
provide more information.

@subsubheading Removed and Renamed Files

The following files were removed:

@itemize @bullet
@item
@code{include/ivideo/vbufmgr.h}
@end itemize

The following files in @file{data/shader} were renamed:

@itemize @bullet
@item
@code{or_lighting.xml} @result{} @code{std_lighting.xml}
@item
@code{or_lighting_detail.xml} @result{} @code{std_lighting_detail.xml}
@item
@code{or_lighting_detail_add.xml} @result{} @code{std_lighting_detail_add.xml}
@item
@code{or_lighting_detail_alpha.xml} @result{}
@code{std_lighting_detail_alpha.xml}
@item
@code{or_lighting_portal.xml} @result{} @code{std_lighting_portal.xml}
@end itemize

@subsubheading Removed Methods and Classes

The following methods have been removed from the @samp{iGraphics3D} interface:

@itemize @bullet
@item
@code{ClearCache()}
@item
@code{CloseFogObject()}
@item
@code{DrawFogPolygon()}
@item
@code{DrawPolygonDebug()}
@item
@code{DrawPolygonFX()}
@item
@code{DrawPolygonMesh()}
@item
@code{DrawTriangleMesh()}
@item
@code{DumpCache()}
@item
@code{GetVertexBufferManager()}
@item
@code{GetZBuffAt()}
@item
@code{OpenFogObject()}
@end itemize

From @samp{iRenderView}, the following fog-related methods have been removed.
Fog is now calculated within the renderer.

@itemize @bullet
@item
@code{CalculateFogMesh()}
@item
@code{CalculateFogPolygon()}
@end itemize

From @samp{iMeshObject} and @samp{iParticle}, the following rendering-related
methods have been removed:

@itemize @bullet
@item
@code{Draw()}
@item
@code{DrawTest()}
@end itemize

Apart from these methods, the following classes and structures have been
removed or have become private, and are no longer available to client code:

@itemize @bullet
@item
@code{G3DFogInfo}
@item
@code{G3DPolygonDFP}
@item
@code{G3DPolygonDPFX}
@item
@code{G3DPolygonDPF}
@item
@code{G3DPolygonDP}
@item
@code{G3DPolygonMesh}
@item
@code{G3DTriangleMesh}
@end itemize

@subheading Query Macros

The macro @code{CS_QUERY_REGISTRY_PLUGIN()} has been added to
@file{iutil/plugin.h}. This is a convenience macro which embodies the common
idiom of first querying the object-registry for an object implementing some
interface, and then asking the plugin manager to load a plugin supplying the
desired object if it was not found in the object-registry. It also registers
the object with the object-registry if the plugin manager loads it
successfully.

@subheading Random Number Generator Changes

The global function @code{csFastRandFloat()} has been retired.  In its stead is
the new instantiable class @samp{csRandomFloatGen}, which is modeled after the
@samp{csRandomGen} class.  Unlike the old @code{csFastRandFloat()} function
which was shared by all clients, instances of @samp{csRandomFloatGen} can be
controlled and seeded individually, thus making it far more flexible and
useful.  (Note that the more general-purpose @samp{csRandomGen} class is also
able to vend floating point numbers.)

@subheading @samp{iImage} Changes

The @samp{iImage} interface has been reduced to a level where it merely serves
as a container for pixel data; however, the image editing functionality was
only relocated, not removed.

Forbidding direct manipulation of an @samp{iImage}'s pixel data has the 
following consequences:
@itemize bullet
@item
The @code{Clone()} function was removed. The
@samp{csImageMemory} class provides a constructor that copies the pixel data
from another @samp{iImage} object, providing a functionality equal to 
@code{Clone()}.
@item
To edit the pixel data of an image, create a clone of an image (e.g. a
@samp{csImageMemory} as mentioned above) and manipulate the data in the newly
cerated instance.
@item
If the image data is needed in another
format, as the @code{SetFormat()} call has been removed from the interface.
@item
The image editing functionality found in methods such as @code{Rescale()},
@code{Sharpen()} was moved into the @samp{csImageManipulate} class.
@item
The @code{CopyXXX()} method that copied an image into another are now provided
by @samp{csImageMemory}.
@end itemize

As a side-effect of these changes, the @samp{csImageFile} and 
@samp{csImageMemory} were merged and the former removed.

@subheading @samp{iMaterialList} Change

The function @code{iMaterialList::NewMaterial()} now needs an additional
name parameter. It is not recommended to change the name later.

@subheading @code{iObjectModel} Change

The function @code{iObjectModel::GetObjectBoundingBox()} only has one
parameter now. The optional @samp{type} parameter has been removed as it
was not implemented anywhere. In addition to that the constants
@code{CS_BBOX_NORMAL}, @code{CS_BBOX_ACCURATE}, and @code{CS_BBOX_MAX}
are also removed.

@subheading @code{iImageIO::Load()} Parameter Change

@code{iImageIO::Load()} now requires the image source data in an 
@samp{iDataBuffer} object, instead of separate @samp{buffer} and @samp{size}
parameters.

@subheading @samp{iRenderBuffer} Renderer Independency

The @samp{iRenderBuffer} interface was made renderer-independant. Consequently,
creation was moved out of @samp{iGraphics3D} and into @samp{csRenderBuffer}.
The semantics of the parameters have changed, too; notably, instead of 
specifying the byte size of a buffer, the element count is specified. The same
change has been made to @code{CopyToBuffer()} (which has been renamed to 
@code{CopyInto()} to enforce human correction of the parameters).
