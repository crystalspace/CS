@c -*-texinfo-*-
@node API Modifications 98, API Modifications 96, API Modifications, API Modifications
@appendixsec @sc{api} Changes from 0.96 to 0.98
@cindex @sc{api} Changes

This section documents the major changes between versions 0.96 and 0.98 of of
Crystal Space.

@subheading Polygon Texture Mapping Changes
@cindex @code{iPolygon3D}
@cindex @code{iPolyTexNone}
@cindex @code{iPolyTexGouraud}
@cindex @code{iPolyTexFlat}
@cindex @code{iPolyTexLightMap}
@cindex shading

The following interfaces have been removed: @code{iPolyTexNone},
@code{iPolyTexGouraud}, @code{iPolyTexFlat}, and  @code{iPolyTexLightMap}.
The combined @sc{api} from @code{iPolyTexNone} and the @code{iPolyTexLightMap}
have moved to @code{iPolygon3D} itself.

@code{iPolygon3D->SetTextureType()} and @code{GetTextureType()} have been
removed.  Instead use:

@itemize @bullet
@item
@code{iPolygon3D->EnableTextureMapping()}
@item
@code{iPolygon3D->IsTextureMappingEnabled()}
@end itemize

@code{iPolygon3D->GetPolyTexType()} has been removed.

The @samp{shading} keyword in polygons now accepts a boolean value
instead of @samp{NONE}, @samp{FLAT}, @samp{GOURAUD}, or @samp{LIGHTMAP}.
With this you can enable/disable lightmapping.

If you want gouraud shaded polygons you should use the @samp{genmesh}
mesh object plugin instead.

@subheading Bezier Curve Changes
@cindex Bezier Curve Changes
@cindex @code{iCurveTemplate}
@cindex @code{iCurve}
@cindex @code{iBezierState}
@cindex @code{iBezierFactoryState}

The notion of curve templates has been reworked. @code{iCurveTemplate} has
been removed and it's functionality has moved to @code{iCurve} itself.
As a consequence of this change the bezier addon loader has been removed.
Also curves have been seperated from the thing plugin and now live in the
'bezier' plugin. So a curve like this in the past:

@example
<addon>
  <plugin>crystalspace.mesh.loader.thing.bezier</plugin>
  <params>
    <name>b1</name>
    <material>mosaic</material>
    <v>0</v> <v>1</v> <v>2</v>
    <v>3</v> <v>4</v> <v>5</v>
    <v>6</v> <v>7</v> <v>8</v>
  </params>
</addon>
<meshfact name="tunnel">
  <plugin>crystalspace.mesh.loader.factory.thing</plugin>
  <params>
    <curvecenter x="0" y="0" z="0" />
    <curvescale>80</curvescale>
    <curvecontrol x="5" y="2" z="0" u="1" v="0" />
    @dots{}
    <curve name="bez">b1</curve>
  </params>
</meshfact>
@end example

@noindent
should now become (mark the new plugin line):

@example
<meshfact name="tunnel">
  <plugin>crystalspace.mesh.loader.factory.bezier</plugin>
  <params>
    <curvecenter x="0" y="0" z="0" />
    <curvescale>80</curvescale>
    <curvecontrol x="5" y="2" z="0" u="1" v="0" />
    @dots{}
    <curve name="b1">
      <material>mosaic</material>
      <v>0</v> <v>1</v> <v>2</v>
      <v>3</v> <v>4</v> <v>5</v>
      <v>6</v> <v>7</v> <v>8</v>
    </curve>
  </params>
</meshfact>
@end example

On the @sc{api} side nothing much changes except that when you use
the bezier mesh plugin you need to use @code{iBezierState} and
@code{iBezierFactoryState}.

The @code{iThingEnvironment} no longer has code to maintain bezier curve
templates.

@subheading iThingState and iPolygon3D Changes
@cindex @code{iThingState}
@cindex @code{iThingFactoryState}
@cindex @code{iPolygon3D}
@cindex @code{iObject}
@cindex @code{iMeshObject}
@cindex @code{iMeshObjectFactory}

@code{iPolygon3D} and @code{iThingState} no longer implement @code{iObject}.
So the @code{QueryObject()} function has been removed. Polygons can still
have names though. Added @code{SetName()} and @code{GetName()} for that.

@code{iPolygon3D} has been split in @code{iPolygon3D} and
@code{iPolygon3DStatic}. The static version contains all static data that
can be put in a factory. Several functions like
@code{iThingState->CreatePolygon()} will now return @code{iPolygon3DStatic}.

@code{iThingState} has been split in @code{iThingState} and
@code{iThingFactoryState}. A thing mesh no longer implements both a mesh
object and a mesh object factory. Instead things now work like usual
mesh objects where @code{iMeshObjectType->NewFactory()} creates a
factory that implements @code{iThingFactoryState} and
@code{iMeshObjectFactory->NewInstance()} creates an instance that implements
@code{iThingState}. The engine convenience functions to create a thing
mesh will automatically create both the factory and mesh so you don't
have to worry about that. You can use @code{iThingState->GetFactory()}
from a thing mesh object to get the @code{iThingFactoryState} so you can
build the polygons. Note that @code{SCF_QUERY_INTERFACE} of
@code{iThingFactoryState} no longer works on a thing mesh object. You must
use @code{GetFactory}.

@subheading Polygon Planes
@cindex @code{iPolyTxtPlane}
@cindex @code{iThingEnvironment}

Polygon planes are removed. So it is no longer possible to use
the plane addon loader to define texture mapping for a polygon outside
of the polygon itself. To fix this you must specify all texture mapping
information in the @code{texmap} statement of the polygon. @file{map2cs}
now correctly outputs polygons like this (no longer outputs planes) and
@file{levtool} can convert old style maps to new format like this:

@code{iThingEnvironment} no longer has code to maintain polygon texture
mapping planes.

The plane loader and saver addons have been removed from the thing
loader plugin.

Removed @code{iPolyTxtPlane} interface. Added
@code{iPolygon3DStatic->GetTextureSpace()} function to get texture space
definition for polygon.

@example
levtool -planes yourmap.zip
@end example

@subheading Portal changes
@cindex @code{iPortal}

Several methods in @code{iPortal} have changed slightly. For example
@code{SetMirror} now expects a plane instead of a polygon.

@subheading Datatype changes

The @code{csSome}, @code{csConstSome} and @code{uint} types have been removed.
Use @code{void*}, @code{const void*} and @code{unsigned int} instead.

@subheading csHashMap changes
@cindex @code{csHashMap}
@cindex @code{csHashIterator}
@cindex @code{csGlobalHashIterator}

@code{csHashIterator} can no longer iterate over all objects. To do that
you need to use @code{csGlobalHashIterator}.

@subheading Procedural textures

Instead of only built-in types, procedural textures have been moved into 
plugins. That means that the @code{<type>} token now works the same way
as the @code{<plugin>} token for meshes. That is, either specify a full
class ID (e.g. @code{crystalspace.proctex.loader.fire}), or a shortcut
specified in the @code{<plugins>} token of the world. To simulate the
old @code{<type>} behaviour, paste the following lines into a map's 
@code{<plugin>} section:

@example
<plugin name="dots">crystalspace.texture.loader.dots</plugin>
<plugin name="fire">crystalspace.texture.loader.fire</plugin>
<plugin name="water">crystalspace.texture.loader.water</plugin>
<plugin name="plasma">crystalspace.texture.loader.plasma</plugin>
@end example

This requires that you move the @code{<plugin>} block in front of the 
@code{<textures>} block, as otherwise the shortcuts won't be recognised.

The behaviour of procedural textures also differs as a material of the same
name was created along with the texture; this isn't the case any more, you
have to create a material which uses the procedural texture manually.

In addition, the loader now doesn't distinguish between normal and procedural
textures any more, both are loaded with the same @code{<texture>} block. The 
syntax recognized is a combination of both old @code{<texture>} and 
@code{<proctex>} tokens - so renaming all @code{<proctex>} to @code{<texture>}
tags is sufficient to convert a level (apart from fixing the @code{<type>}
tokens.)

@subheading Regions
@cindex @code{iRegion}
@cindex @code{iEngine}
@cindex @code{iLoader}

Region handling has changed considerably. The engine no longer has the
concept of a current region. The engine still manages all regions though.
Objects also no longer register themselves to the current region. It is
the responsability of the object creator to do that. The standard loader
has support for adding objects to a region now.

The following functions have been removed from @code{iEngine}:

@itemize
@item
@code{SelectRegion()}
@item
@code{GetCurrentRegion()}
@item
@code{AddToCurrentRegion()}
@end itemize

There is one new function @code{iEngine->CreateRegion()} which will create
a new region.

In @code{iLoader} the functions @code{LoadMapFile()} and
@code{ThreadedLoadMapFile()} now expect an optional pointer to a region
in addition with a boolean to restrict searching to that region.

In addition to all these changes the @samp{region} keyword in XML is no
longer supported.

@subheading Mesh objects/factories and iPolygonMesh

Some mesh factories used to support the querying of the @code{iPolygonMesh}
interface (e.g. Thing, Sprite3D, Genmesh). Due to the way this was 
implemented internally this caused leaks. So, querying @code{iPolygonMesh} 
directly from the object is now discouraged. Although it may still work in 
some cases, this feature may be dropped without further notice and may not 
work in all cases. 

Similar for mesh objects. Querying @code{iPolygonMesh} is discouranged here
as well.

Instead, if you want the polygon mesh from an object, use the 
@code{GetObjectModel()} method from the @code{iMeshObject} interface, resp.
query for the @code{iObjectModel} interface in case of a factory, and utilize 
one of the @code{GetPolygonMeshXXX()} methods, depending on what you need 
(the old interface query returned the collision detection mesh.) This has also 
the advantages that you can get different meshes for different purposes 
(currently, visibility culling and collision detection in addition the the 
base mesh), and that those meshes can be overridden by user-defined meshes 
(e.g. if the collision detection mesh needs to have a shape different from 
the visible mesh.) 

@subheading Iterator Changes
@cindex @code{iVisibilityObjectIterator}
@cindex @code{iLightIterator}
@cindex @code{iSectorIterator}
@cindex @code{iObjectIterator}
@cindex @code{iObjectRegistryIterator}
@cindex @code{iStreamIterator}
@cindex @code{csTypedObjectIterator}
@cindex @code{csModelDataActionIterator}
@cindex @code{csModelDataPolygonIterator}
@cindex @code{csModelDataTextureIterator}
@cindex @code{csModelDataMaterialIterator}
@cindex @code{csModelDataObjectIterator}
@cindex @code{csNodeIterator}

Changed the following iterators to conform to the following iterator standard:
@example
  bool iterator->HasNext() returns true if there are more items.
  T* iterator->Next() returns next element or 0.
  void Reset() optionally resets the iterator (not all implement this).
@end example

@itemize
@item
@code{iVisibilityObjectIterator}
@item
@code{iLightIterator}
@item
@code{iSectorIterator}
@item
@code{iObjectIterator}
@item
@code{iStreamIterator}
@item
@code{iObjectRegistryIterator}
@item
@code{csTypedObjectIterator}
@item
@code{csModelDataActionIterator}
@item
@code{csModelDataPolygonIterator}
@item
@code{csModelDataTextureIterator}
@item
@code{csModelDataMaterialIterator}
@item
@code{csModelDataObjectIterator}
@item
@code{csNodeIterator}
@end itemize


@subheading Changes to AWS

@code{iAWS::CreateCustomCanvas} was removed.  To set up the AWS with a cavas,
use @code{iAWS::SetupCanvas} instead. 

@subheading csPArray removed
@cindex @code{csPArray}
@cindex @code{csArray}

@code{csPArray} has been removed in favor of @code{csArray}. So use
@code{csArray<T*>} instead of @code{csPArray<T>}.

@subheading csStrVector and iStrVector removed
@cindex @code{csStrVector}
@cindex @code{iStrVector}
@cindex @code{csStringArray}
@cindex @code{iStringArray}
@cindex @code{FindFiles}
@cindex @code{MountRoot}

@code{csStrVector} has been removed in favor of @code{csStringArray}.
This means that functions like @code{iVFS::MountRoot()} and
@code{iVFS::FindFiles()} now return an @code{iStringArray}.

@subheading csVector and csBasicVector removed
@cindex @code{csVector}
@cindex @code{csBasicVector}
@cindex @code{csArray}
@cindex @code{csRefArray}
@cindex @code{csPDelArray}

@code{csVector} and @code{csBasicVector} have been removed. Instead you
should use one of the templated arrays: @code{csArray}, @code{csPDelArray},
or @code{csRefArray}.

If you were using a regular @code{csVector} then this can usually be
replaced directly by @code{csArray<type*>} with @samp{type} the type you
were storing in the vector.

If you subclassed from @code{csVector} in order to override @code{FreeItem()}
then you have to decide what to do depending on the code in @code{FreeItem()}.
If that code performed a @code{delete} then you can use @code{csPDelArray}.
If that code performed a @code{DecRef()} then you can use @code{csRefArray}
but you still have to be careful because @code{csRefArray} will automatically
incref objects that are pushed on the array. In other cases you probably
need to handle deletion manually.

@code{csVector} also allowed to override @code{Compare()} and
@code{CompareKey} in order to drive @code{QuickSort}, @code{FindSortedKey},
@code{InsertSorted}, and @code{FindKey}. This is no longer possible. Instead
you can do the following transformation. First the old code:

@example
class MyVector : public csVector
@{
public:
  virtual ~MyVector ()
  @{
    DeleteAll ();
  @}
  virtual void FreeItem (void* item)
  @{
    delete (MyType*)item;
  @}
  virtual int Compare (void* i1, void* i2, int mode) const
  @{
    @dots{}
  @}
  virtual int CompareKey (void* i, const void* key, int mode) const
  @{
    @dots{}
  @}
@};
@end example

This could be transformed roughly to the following class:

@example
class MyVector : public csPDelArray<MyType>
@{
public:
  static int Compare (MyType const* i1, MyType const* i2)
  @{
    @dots{}
  @}
  static int CompareKey (MyType const* i, void* key)
  @{
    @dots{}
  @}
@};
@end example

In the calls to @code{InsertSorted}, @code{FindKey}, @dots{} you would then
pass in one of the static functions to use.

@subheading Array changes
@cindex @code{csArray}
@cindex @code{csPDelArray}
@cindex @code{csRefArray}
@cindex @code{csStringArray}
@cindex @code{csGrowingArray}
@cindex @code{csDirtyAccessArray}

All arrays have been modified to inherit from @code{csArray}. This means
that there are some slight @sc{api} changes because many functions were
not consistent with @code{csArray}.

Also @code{csGrowingArray} has been renamed to @code{csDirtyAccessArray}.

@subheading iEventQueue clients now responsible for their own references
@cindex @code{csEventQueue}
@cindex @code{iEventQueue}
@cindex @code{csEvent}
@cindex @code{iEvent}
@cindex @code{csPoolEvent}
@cindex @code{csEventOutlet}
@cindex @code{iEventOutlet}
@cindex @code{csEventCord}
@cindex @code{iEventCord}

Clients passing a @code{csEvent} instance @code{iEventQueue::Post()} or
@code{iEventOutlet::Post()} must now @code{DecRef()} the @code{csEvent} after
the call, since the @code{iEventQueue} will @code{IncRef()} it during the call
and then @code{DecRef()} it when it's been handled.

This means that if you are calling @code{Post()} like this:
@example
  iEvent *e = new csEvent (foo, bar);
  eventq->Post(e);
@end example
You must now call it like this:
@example
  csRef<iEvent> *e = csPtr<iEvent> (new csEvent (foo, bar));
  eventq->Post(e);
@end example

Events created with @code{iEventQueue::CreateEvent()} or
@code{iEventOutlet::CreateEvent()} are unaffected by this change.

@subheading New Renderer Related Changes

The mesh object @sc{api} has changed considerably so we recommend looking at the
documentation on that to see how to modify your own mesh object for the new
@sc{api}. In this section we describe @sc{api} modifications that are relevant
for user applications:

For @code{iLight}: @code{SetRadius}, @code{GetRadius}, and @code{GetSquaredRadius} have been replaced with @code{SetInfluenceRadius}, @code{GetInfluenceRadius}, and @code{GetInfluenceRadiusSq}.

For @code{iMaterialEngine} and related: @code{GetTextureWrapper} for
layers now expects a @code{csStringID} instead of an integer.

