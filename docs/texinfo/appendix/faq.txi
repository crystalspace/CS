@c -*-texinfo-*-
@node FAQ, API Modifications, Glossary, Top
@appendix Frequently Asked Questions (@sc{faq})
@cindex Frequently Asked Questions
@cindex @sc{faq}

This is a list of frequently asked questions and their answers.  If you have
some questions about Crystal Space, try consulting this list first.

The first section contains practical questions and answers. The second
section (see later) contains more technical questions.

More FAQs can also be found online in the CS Wiki 
(@uref{http://crystal.sourceforge.net/phpwiki/index.php?FAQ}).

@itemize @bullet
@item
@strong{Q}: From where can I download Crystal Space?

@strong{A}: The latest release of Crystal Space is always available from the
Crystal Space home page, and from the Crystal Space @sc{ftp} site
@uref{ftp://sunsite.dk/projects/crystal/}. You can
also access the bleeding-edge developmental version.  @xref{Where to Get}.

@item
@strong{Q}: What do I need to compile Crystal Space?

@strong{A}: You need the source code, which you can obtain in a variety of
ways.  @xref{Where to Get}.  You also need a compiler and development system
for the platform which you are using.  Some of the supported compilers are
@sc{gcc} (including @sc{MingW} and @sc{Cygwin}), @sc{msvc} and Code Warrior.

@item
@strong{Q}: What do you need to run Crystal Space?

@strong{A}: You need the following items:

@itemize @minus
@item
A compiled executable program such as @file{walktest} or @file{blocks}, for
example.  These are demo programs included in the main source archive.

Note that there exist two types of executables: staticly linked and
dynamically linked.  If you have a staticly linked executable (for example,
the @sc{dos} executable will always be static) then you don't need any of the
following drivers.  Otherwise you will need the remaining items.

@item
A 3D rasterizer plug-in.  You can choose either the software renderer or else
one of the hardware accelerated renderers.  You also have to choose the
correct library for your system.  On OS/2 and Windows (32 bit) this will be a
@file{.DLL} file.  On most Unix systems this will be an @file{.so} file.

@item
A 2D graphics driver which is particular to your platform.  The 3D rasterizer
displays its rendered images thorugh the 2D graphics driver.

@item
A network driver, such as the @sc{bsd}-style Sockets driver.  Use this if
the application you want to use relies upon network access.

@item
Many of the Crystal Space applications also need several other plugins. For
example plugins which implement 3D sprites, particle systems, ... In general
the Crystal Space distribution will contain source for all of them.

@item
You should also have @file{standard.zip} which is a library of standard
resources used and shared by several of the Crystal Space applications.  You
should @emph{not} unpack this file.  Crystal Space reads from @sc{zip} files
directly.

@item
Finally you need at least one map file.  The map file is also typically a
@sc{zip} archive.  Possible map files, among others, are @file{flarge.zip},
@file{maze.zip}, and @file{room.zip}).  In addition to these map files you
also need the standard texture archive @file{stdtex.zip}. You should
@emph{not} unpack these files.  Note that @file{standard.zip} is not a
map file. All map files and related data files are usually
located in the @file{data} directory.
@end itemize

@item
@strong{Q}: I downloaded Crystal Space but it won't run.  What could be the
cause?

@strong{A1}: Are you sure that you have downloaded all the necessary
components, as explained by the previous section? If not, then download the
missing components.

@strong{A2}: In general, Crystal Space requires an 8, 15, 16, or 32-bit
display and will not work with other displays modes.  Note, however, that the
MacOS/X Server, OpenStep, and NextStep ports of Crystal Space are not subject
to this limitation.

@strong{A3}: If you are using a dynamicly linked executable then the required
plug-in modules, such as 3D renderer, 2D driver, etc.  usually must reside in
the same directory.  On BeOS, the plug-in modules must be located in an
@file{add-ons} subdirectory.  Most ports of Crystal Space use plug-in modules,
with the notable exception of the @sc{dos} port which is statically linked.

@strong{A4}: Are you certain that you are trying to load the correct map file?
If you are running the application from the command-line, then you can try
specifying the map file on on the command-line, like this:

@example
% walktest flarge
@end example

Where @samp{flarge} is the name of the map file you wish to use.  In this case,
@samp{flarge} corresponds to the @file{flarge} directory which is included
with CS.  Also note that @file{flarge} itself requires the file
@file{stdtex.zip} which contains all the textures.

Alternately, for WalkTest, you can change the @samp{WorldFile} setting in its
configuration file @file{CS/data/config/walktest.cfg}.  For example:

@example
Walktest.Settings.WorldFile = flarge
@end example

@strong{A5}: If all else fails ask a question on the Crystal Space mailing
list.  @xref{Mailing Lists}.

@item
@strong{Q}: What documentation is available?  Where can I find it?

@strong{A}: There is a lot of documentation available.  Not all of it is
completely up-to-date but we try to do our best in keeping it as up-to-date as
possible.  Refer to the section in the Crystal Space manual which discusses
documentation resources.  @xref{Documentation Resources}.

@item
@strong{Q}: I don't have lots of memory.  Can I still run Crystal Space?

@strong{A1}: You may want to decrease the size of the texture cache with the
@samp{-cache=<size>} command-line option or the @samp{CACHE} configuration
option in @file{soft3d.cfg} if you are using the software renderer.  By
default the size of the texture cache is quite large (typically 5 to eight
megabytes in size), so adjusting this value might be useful for low-memory
systems.

@strong{A2}: Using a smaller window size and a lower bit-depth can also
decrease memory usage.  In addition to the memory used for the actual graphics
display, Crystal Space uses a Z-buffer containing 4-byte values with the same
dimensions as the display.  Therefore, a display with dimensions of 640x480
uses a Z-buffer of 1,228,800 bytes.

@strong{A3}: If you are still low on memory there is only one thing you can
do: decrease the complexity of the map.  For every polygon in the world a lot
of memory used.  If you just want to try the engine you can run Crystal Space
with some of the simpler worlds such as @file{room.zip} or @file{maze.zip}.

@item
@strong{Q}: Crystal Space is really slow on my computer.  What can I do to
speed it up?

@strong{A1}: Crystal Space is a 6@sc{dof} engine.  It needs to do
semi-perspective correct texture mapping to get a nice display and
calculations to achieve this are slow.  You can expect that Crystal Space will
probably need the same kind of computer as a game such as Quake 1 or Quake 2,
at least a Pentium or a very fast 486 with a floating point co-processor.
Also note that Crystal Space is still in the developmental stage and has not
yet been fully optimized.  You might try using smaller window dimensions
with the @samp{-mode=} option.  @xref{Common Command Line Options}.

@strong{A2}: Use a hardware accelerated graphics card and driver.  Such cards
are quite popular these days and can perform extremely well, especially when
compared to Crystal Space's software renderer.

@item
@strong{Q}: I want to create textures for Crystal Space.  What palette should I
use?  How big should I create the textures?  What format can I use?

@strong{A1}: The palette does not really matter because Crystal Space
calculates its own optimal palette given a set of input textures.  But there
are some things to keep in mind.  Try to get the number of different colors as
low as possible without sacrificing for quality and if you design a set of
textures that are meant to be used together it is always best to let them use
a similar palette.  This will make it easier for Crystal Space to calculate a
good palette.

@strong{A2}: The width and height of a texture must be a power of 2 (such as
8, 16, 32, 64, @dots{}).  That's about the only restriction.  Textures need
not be square.  You can have textures with sizes like 16x256. If a texture
does not conform to the above mentioned limitations then it will be scaled.
This may mean that there is quality degradation though!

@strong{A3}: Crystal Space textures may be in any of the supported image
formats, such as @sc{png}, @sc{tga}, @sc{bmp}, @sc{jpg}, and @sc{gif}.

@strong{A4}: Unless a texture is not meant for tiling you should make sure
that it can be tiled.  This means that if you put a number of textures next to
each other or above each other the boundaries should seemlessly integrate with
each other.  Of course, it is entirely possible to create textures that are
specifically drawn for untiled usage.  An example would be a texture
representing a computer keyboard.

@item
@strong{Q}: I would like to contribute to Crystal Space.  What can I do?

@strong{A}: Have a look at the section of this manual about contributing
to the project (@pxref{Contributing}), and take a look at the To-Do and
Bug lists on the Developer's Project page at SourceForge:

@noindent
@uref{http://sourceforge.net/projects/crystal/}

@noindent You can also contact the mailing list (@pxref{Mailing Lists}) in
order to coordinate your efforts with those of other people.

@item
@strong{Q}: How does Crystal Space work?

@strong{A1} If you want to know how you can use CS, you can look at the
chapters describing the libraries of which CS consists, @xref{Libraries}.  Or
you can look at the plug-ins, @xref{Plug-In Drivers}.  If you want to know how
it works internally, @xref{Internals}.

@strong{A2}: Read any other documentation related to this project as mentioned
earlier in this @sc{faq}.

@strong{A3}: If you need more information, you should consider posting your
queries to the Crystal Space mailing list, @ref{Mailing Lists}.

@item
@strong{Q}: I want to write a game with Crystal Space.  Can I do this?

@strong{A1}: The ultimate purpose of Crystal Space is that it will become a
useable and powerful engine for writing games and other graphics visualization
programs.  As a project which is still under development, it may be simple or
difficult to build your particular game, depending upon your specific
requirements.  One way to improve the state of Crystal Space so that it better
fits your needs is to contribute to the project yourself.

@strong{A2}: Crystal Space is under the @sc{lgpl} licensing policy so you can
make commercial or shareware products using it.  For more details about what
you can and cannot do, see the license, @ref{License}.

@item
@strong{Q}: How stable is the @sc{api} for Crystal Space?

@strong{A}: The @sc{api} which you can find in the 0.90 release should be about
95% stable as compared to the 1.0 release. After 1.0 we will make sure
to keep backwards compatibility (until we release 2.0 :-)
@end itemize

The following section lists some more technical questions.

@itemize @bullet
@item
@strong{Q}: I updated Crystal Space from @sc{cvs} (with either @samp{WinCVS} or
command-line) but it seems some files are missing.

@strong{A}: When doing an update from @sc{cvs} it is important not to
forget the @samp{-d} and @samp{-P} commandline options. Otherwise you
will not get new directories and old empty directories will be
everywhere. Using @samp{WinCVS} it is also possible to set these
options.  @xref{WinCVS Tutorial}.

@item
@strong{Q}: Why isn't my object lit correctly (all black) and why doesn't
lighting update when I move it?

@strong{A}: Keep in mind that things don't automatically update their
static lightmaps as that is expensive. But for dynamic lighting and other
mesh objects you can dynamically let the object be lit. But in order to
actually make this work you need to call @code{DeferUpdateLighting()}
on the object when it is first created, when lights in the vicinity move,
or when the object itself moves.  @xref{HOWTO Mesh LightAnim}.

@item
@strong{Q}: Why isn't my polygon lit correctly? It is simply full bright.

@strong{A}: Both the software and OpenGL renderer have a limitation on
lightmap size. For the software renderer the limitation is that the
final resulting lit texture may not exceed 1500000 pixels. To calculate
the final resulting lit texture size the easiest way is to take the
texture size that is used on the polygon (i.e. 64x64 for example) and
calculate how many times the texture is repeated on that polygon. If the
given texture is repeated four times on the polygon then you basically
have a total texture of 256x256 which will be fine. For the OpenGL
renderer the limitation is that a lightmap cannot be bigger than 256x256.
Note that there will be a lightmap lumel for every 16x16 texels on the
polygon. To avoid this limitation you basically have four possible
solutions: (1) split the polygon into smaller polygons, (2) use a smaller
base texture (this will also reduce size of lightmap/lit texture), (3)
decrease the number of times the texture is tiled on the polygon, and
finally (4) use a low-resolution base texture and a high-resolution detail
texture to add detail (this only works for OpenGL).

@item
@strong{Q}: I added lights, and/or moved geometry in my level but they are not
correctly lit.  What did I do wrong?

@strong{A}: Crystal Space does not automatically recalculate lighting.
To do that you have to use the @samp{-relight} commandline option.

@item
@strong{Q}: Every time I start my Crystal Space based application the lights
are recalculated.  How can I avoid that?

@strong{A}: Use the @samp{-relight} commandline option. This will make
sure the lighting gets recalculated AND cached in the zip file of your
level.

@item
@strong{Q}: I'm confused by the Crystal Space coordinate system.  The 3D
renderer seems to work in reverse y.  What's up?

@strong{A}: When talking in 3D, Crystal Space defines the positive X axis
as pointing to the right, the positive Y axis as pointing upwards, and
the positive Z axis pointing forwards. 2D operations in the 3D renderer
(like when drawing polygons using coordinates perspective projected by
the engine) work with positive X axis to the right (as usual), and positive
Y axis pointing upwards (so (0,0) is in the bottom-left corner). This is the
exact reverse of how screen coordinates are usually defined but corresponds
better with the Y axis pointing upwards in 3D coordinates).
However, when getting mouse events the normal screen
space coordinate system is used with (0,0) in the top-left corner.

@item
@strong{Q}: Why can't I get the
@code{iThingState} / @code{iSprite3DState} / @dots{} from my mesh wrapper?  I
do @code{SCF_QUERY_INTERFACE} from the mesh and it returns @samp{NULL}.

@strong{A}: A common error is to try to query the state interface for
a mesh object from the @code{iMeshWrapper} instance. However it is not
@code{iMeshWrapper} that represents the mesh object. @code{iMeshWrapper} is
only a stub in the engine to wrap a mesh object so the engine can use
it. To get the state interface you must query from the @code{iMeshObject}
instance instead. You can get this instance with @code{mesh->GetMeshObject()}.

@item
@strong{Q}: I do not understand when I have to use @code{DecRef()} and when
not.  Can you explain this reference counting to me?

@strong{A1}: This answer is not valid if CS_STRICT_SMART_POINTERS
flag is set (which is set by default in recent versions of CS). If you
have this flag set then refer to answer 2 of this question.
Reference counting keeps track of how many times
the object is referenced throughout the system. The owner of a reference
is also responsible for cleaning up that reference later. You are not
responsible for cleaning up references owned by other modules (like the
engine). In general you should do @code{DecRef()} in the following
cases:

@itemize @bullet
@item
On the pointer returned by the following macros:
@itemize @bullet
@item
@code{SCF_QUERY_INTERFACE()}
@item
@code{SCF_QUERY_INTERFACE_SAFE()}
@item
@code{CS_QUERY_REGISTRY()}
@item
@code{CS_QUERY_REGISTRY_TAG()}
@item
@code{CS_QUERY_REGISTRY_TAG_INTERFACE()}
@item
@code{CS_LOAD_PLUGIN()}
@item
@code{CS_QUERY_PLUGIN_ID()}
@item
@code{CS_QUERY_PLUGIN_CLASS()}
@end itemize
@item
On a pointer on which you explicitely did @code{IncRef()}.
@item
On an object that you allocated yourselves (which inherits
from @code{iBase} or another @sc{scf} interface).
@end itemize

You should do @code{DecRef()} when you no longer need the pointer.
In some cases you can do it immediatelly after using the pointer like
in this example:
@example
iThingState* st =
  SCF_QUERY_INTERFACE (mesh->GetMeshObject (), iThingState);
if (st)
@{
  st->blabla @dots{};
  st->DecRef ();
@}
@end example

In other cases you can store the pointer in a global class (your application
class) and call @code{DecRef()} just before the application exits.

@strong{A2}: In recent versions of Crystal Space we now have a new
@code{csRef} class which implements a kind of smart pointer. Smart pointers
make it easier for you to keep track of references. They will automatically
@code{DecRef()} when they are ready. Here is an example of their usage:
@example
csRef<iThingState> st =
  SCF_QUERY_INTERFACE(mesh->GetMeshObject(), iThingState));
if (st)
@{
  st->blabla @dots{};
@}
@end example

If you compare this to the last example in answer one you can see that
the code is roughly the same. You can use the @samp{st} variable just like
you would use the normal @code{iThingState} reference. The only difference
is that you don't have to take care of calling @code{DecRef}.

In very recent versions of CS the CS_STRICT_SMART_POINTERS flag is set
which means that the only way to actually use the result of macros
like @code{SCF_QUERY_INTERFACE} and others is to assign them to a
@code{csRef}. @xref{HOWTO Smart Pointers}.

@item
@strong{Q}: My objects are rendered incorrectly.  It seems as if parts of it
sometimes appear and sometimes disappear.

@strong{A}: Incorrect rendering of objects can be caused by bugs but there
is one common cause of this problem which is Z-buffer related. It is important
to realize that Crystal Space does NOT clear the Z-buffer every frame (nor
does it clear the screen). By default Crystal Space depends on the geometry
itself to clear the Z-buffer. For example, if you have a room with a single
object in it then you should use @samp{ZFILL} mode for the room polygons
(so that the Z-buffer will be filled but not read) and @samp{ZUSE} for
the object (so that the Z-buffer will be both updated and read).

In many cases levels are closed (meaning that there is some exterior object
which blocks the view into infinity). If you have such a convex closed
object at the boundary of your level you can use @samp{ZFILL} for that.
However, there are occasions when this is not possible. Either because there
is no exterior object, the exterior object is not closed, or the exterior
object is not convex. In that case you better use @samp{ZUSE} for all objects
and enable Z-clearing every frame. In world files you can do this by
using the @samp{settings} block and enabling the @samp{clearzbuf} option.

Note that you should invoke the method @code{engine->GetBeginDrawFlags()} in
your call to @code{g3d->BeginDraw()} to ensure that this Z-buffer clearing will
actually work (in fact you should @emph{always} use
@code{GetBeginDrawFlags()}).

@item
@strong{Q}: I'm trying to use some plugin but it says that it cannot find it
(i.e. @code{CS_QUERY_REGISTRY} returns null).

@strong{A}: It is important to realize that @code{CS_QUERY_REGISTRY}
does NOT load a plugin. It only looks for some component in the object
registry. There are two basic ways to load a plugin: the first is to use
@code{csInitializer::RequestPlugins()} and the second is to manually
load the plugin using @code{CS_LOAD_PLUGIN}. @code{RequestPlugins()} is
best because it actually registers the plugin with the object
registry and it also correctly manages config file, commandline and
request plugins (so you can override a plugin on commandline/config file).

@end itemize
