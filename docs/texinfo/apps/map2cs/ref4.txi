@c -*-texinfo-*-
@node map2cs.cfg Game-Specific Data, , map2cs Invoking, map2cs
@subsection Game-Specific Data

This section describes how to access game-specific data from the Crystal Space
engine.

@subsubheading Support in the Crystal Space ``map format''

To support game-specific data, the Crystal Space map format has been
extended, thus allowing you to embed the required data directly in the map
file.

You can add key / value pairs to the map file itself; both to @dfn{things}
and @dfn{sectors}.  To do this, just add @samp{<key name="@var{keyname}"
value="@var{keyvalue}" />} to the appropriate sections.  You can use any
number of keys.  Because not all game-specific information can be bound to
actual geometry, (like @samp{info_deathmatchstart}, for example) there is
also an element called @samp{node}.

A node looks like this:

@example
<node name="nodeName">
	<position x="" y="" z="" />
	<key name="keyName1" value="keyValue1" />
	<key name="keyName2" value="keyValue2" />
	<key name="keyName3" value="keyValue3" />
</node>
@end example

@subsubheading How Does @file{map2cs} Support Game-Specific Data?

@file{map2cs} takes all key / value pairs found in the original map and
attaches them to the appropriate Crystal Space object.  So if you have a brush
based entity, @file{map2cs} will store the data with the ``thing'' that is
generated from the entity.  (Every entity corresponds to exactly one
``thing''.  If there are several sectors, the entity will be split and the
appropriate ``things'' all get the same data.)

If you have a point based entity (lights for example), @file{map2cs} will
generate a node in the appropriate sector, and store all data there.

If you have a manual sector, all data stored with the defining brush gets
stored in the sector.

For informational purposes, @file{map2cs} stores the scaling factor in the
Crystal Space world.  (Because otherwise a game could not interpret
positions.)

@subsubheading How Does Crystal Space Support Game-Specific Data?

@samp{csLoader} generates an instance of @samp{csKeyValuePair} for every
@dfn{key} found in the map file and attaches it to the appropriate Crystal
Space object by calling @code{ObjAdd()}.  Each nodes generates an instance of
@samp{csMapNode}, and this is added to the sector with @code{ObjAdd()} as
well.

To make access to game-specific data simpler, there are some convenience
classes and some convenience functions.

To get the value of a game-specific key you can call:

@example
csKeyValuePair::GetValue(csObject* pObject, char const* key);
@end example

For example:

@example
csSector* pSector = GetCurrentSector();
char const* gravitystr =
    csKeyValuePair::GetValue(pSector, "gravity");
int gravity = atoi(gravitystr);
@end example

Please note that these operations are pretty expensive, so you should
@emph{not} invoke them every frame.  For frequently needed data, you should
read the values once, and store them in some game-specific data fields.  (But
it is still okay, to read the values once in a while; for example reading a
message to be printed, when the user tries to open a locked door without
having first unlocked it.)

To get a specific node you can call:

@example
csMapNode::GetNode(csSector* pSector, char const* name,
    char const* classname=0);
@end example

For example:

@example
csSector* pSector = GetCurrentSector();
csMapNode* pNode = csMapNode::GetNode(
    pSector, "central", "cs_dynlight");
csVector3 pos = pNode->GetPosition();
CreateDynLight(@dots{});
@end example

A more frequent case for nodes will be to iterate over all nodes in a sector
(for example to place monsters or weapons).

For example:

@example
csSector* pSector = GetCurrentSector();
csNodeIterator iter (pSector,"cs_medikit");
while (iter.HasNext ())
@{
  csMapNode* pNode = iter.Next();
  csVector3 pos = pNode->GetPosition();
  CreateMedikit(pos);
@}
@end example
